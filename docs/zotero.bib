@patent{akkaryMethodsApparatusCaching1997,
  type = {patentus},
  title = {Methods and Apparatus for Caching Data in a Non-Blocking Manner Using a Plurality of Fill Buffers},
  author = {Akkary, Haitham and Abramson, Jeffrey M. and Glew, Andrew F. and Hinton, Glenn J. and Konigsfeld, Kris G. and Madland, Paul D. and Joshi, Mandar S. and Lince, Brent E.},
  holder = {{Intel Corp}},
  date = {1997-09-23},
  number = {5671444A},
  url = {https://patents.google.com/patent/US5671444A/en},
  urldate = {2024-01-23},
  abstract = {A data cache and a plurality of companion fill buffers having corresponding tag matching circuitry are provided to a computer system. Each fill buffer independently stores and tracks a replacement cache line being filled with data returning from main memory in response to a cache miss. When the cache fill is completed, the replacement cache line is output for the cache tag and data arrays of the data cache if the memory locations are cacheable and the cache line has not been snoop hit while the cache fill was in progress. Additionally, the fill buffers are organized and provided with sufficient address and data ports as well as selectors to allow the fill buffers to respond to subsequent processor loads and stores, and external snoops that hit their cache lines while the cache fills are in progress. As a result, the cache tag and data arrays of the data cache can continue to serve subsequent processor loads and stores, and external snoops, while one or more cache fills are in progress, without ever having to stall the processor.},
  keywords = {cache,data,fill,fill buffers,store},
  file = {/home/thijs/Zotero/storage/X75A3MVT/Akkary et al. - 1997 - Methods and apparatus for caching data in a non-bl.pdf}
}

@online{AnalysisMitigationL1,
  title = {Analysis and Mitigation of {{L1 Terminal Fault}} ({{L1TF}}) | {{MSRC Blog}} | {{Microsoft Security Response Center}}},
  url = {https://msrc.microsoft.com/blog/2018/08/analysis-and-mitigation-of-l1-terminal-fault-l1tf/},
  urldate = {2024-02-16},
  file = {/home/thijs/Zotero/storage/KUFXFJKS/analysis-and-mitigation-of-l1-terminal-fault-l1tf.html}
}

@patent{boggsMethodStateRecovery1996,
  type = {patentus},
  title = {Method for State Recovery during Assist and Restart in a Decoder Having an Alias Mechanism},
  author = {Boggs, Darrell D. and Brown, Gary L. and Hancock, Michael M. and Parker, Donald D. and Rupnick, Gail M.},
  holder = {{Intel Corp}},
  date = {1996-10-15},
  number = {5566298A},
  abstract = {A state recovery and restart method that simplifies assist handling. The recovery and restart method also handles micro-branch mispredictions. An assist sequence is executed in microcode to assist an error-causing macroinstruction. If data is required from an error-causing macroinstruction, it is fetched, decoded, and macro-alias registers are restored with macro-alias data. To recover the state of the micro-alias registers, micro-alias data from a micro-operation of the flow may be loaded into the micro-alias register. Subsequently, control returns to the Micro-operation Sequence (MS) unit to issue further error correction Control micro-operations (Cuops). In order to simplify restart, the Cuops originating from the error-causing macroinstruction supplied by the translate programmable logic arrays (XLAT PLAs) are loaded into the Cuop registers, with their valid bits unasserted. If microcode requests a restart beginning at one of the Cuops stored in the Cuop register, then the bits for that Cuop and subsequent Cuops are marked valid. Thus, the instruction can be restarted anywhere within the microcode sequence.},
  file = {/home/thijs/Zotero/storage/PS7YD6EM/Boggs et al. - 1996 - Method for state recovery during assist and restar.pdf}
}

@patent{boggsMethodStateRecovery1996a,
  type = {patentus},
  title = {Method for State Recovery during Assist and Restart in a Decoder Having an Alias Mechanism},
  author = {Boggs, Darrell D. and Brown, Gary L. and Hancock, Michael M. and Parker, Donald D. and Rupnick, Gail M.},
  holder = {{Intel Corp}},
  date = {1996-10-15},
  number = {5566298A},
  url = {https://patents.google.com/patent/US5566298A/en?oq=US5566298A},
  urldate = {2024-01-24},
  keywords = {alias,assist,macroinstruction,micro,restart},
  file = {/home/thijs/Zotero/storage/L3QQTQW3/Boggs et al. - 1996 - Method for state recovery during assist and restar.pdf}
}

@inproceedings{brunellaForeshadowVMMFeasibilityNetwork2019,
  title = {Foreshadow-{{VMM}}: {{Feasibility}} and {{Network Perspective}}},
  shorttitle = {Foreshadow-{{VMM}}},
  booktitle = {2019 {{IEEE Conference}} on {{Network Softwarization}} ({{NetSoft}})},
  author = {Brunella, Marco Spaziani and Bianchi, Giuseppe and Turco, Sara and Quaglia, Francesco and Blefari-Melazzi, Nicola},
  date = {2019-06},
  pages = {257--259},
  publisher = {{IEEE}},
  location = {{Paris, France}},
  doi = {10.1109/NETSOFT.2019.8806712},
  url = {https://ieeexplore.ieee.org/document/8806712/},
  urldate = {2024-01-16},
  abstract = {On August 14, 2018, a new set of vulnerabilities collectively named ”L1 terminal fault” were announced. Systems with microprocessors utilizing out-of-order execution could allow unauthorized disclosure of information residing in the L1 data cache, by tweaking the virtual memory abstraction. The vulnerability was therein mentioned for three different scenarios. In this demo-paper, we provide practical evidence about the feasibility of the most complex ”VMM” case of an attacker residing in a Virtual Machine (VM), and targeting information leakage from the host OS and other independent VMs.},
  eventtitle = {2019 {{IEEE Conference}} on {{Network Softwarization}} ({{NetSoft}})},
  isbn = {978-1-5386-9376-6},
  langid = {english},
  file = {/home/thijs/Zotero/storage/KCBS9MZM/Brunella et al. - 2019 - Foreshadow-VMM Feasibility and Network Perspectiv.pdf}
}

@inproceedings{bulckForeshadowExtractingKeys2018,
  title = {Foreshadow: {{Extracting}} the {{Keys}} to the {{Intel}} \{\vphantom\}{{SGX}}\vphantom\{\} {{Kingdom}} with {{Transient}} \{\vphantom\}{{Out-of-Order}}\vphantom\{\} {{Execution}}},
  shorttitle = {Foreshadow},
  author = {Bulck, Jo Van and Minkin, Marina and Weisse, Ofir and Genkin, Daniel and Kasikci, Baris and Piessens, Frank and Silberstein, Mark and Wenisch, Thomas F. and Yarom, Yuval and Strackx, Raoul},
  date = {2018},
  pages = {991},
  url = {https://www.usenix.org/conference/usenixsecurity18/presentation/bulck},
  urldate = {2024-02-02},
  eventtitle = {27th {{USENIX Security Symposium}} ({{USENIX Security}} 18)},
  isbn = {978-1-939133-04-5},
  langid = {english},
  file = {/home/thijs/Zotero/storage/43JXYLW8/Bulck et al. - 2018 - Foreshadow Extracting the Keys to the Intel SGX .pdf}
}

@inproceedings{canellaFalloutLeakingData2019,
  title = {Fallout: {{Leaking Data}} on {{Meltdown-resistant CPUs}}},
  shorttitle = {Fallout},
  booktitle = {Proceedings of the 2019 {{ACM SIGSAC Conference}} on {{Computer}} and {{Communications Security}}},
  author = {Canella, Claudio and Genkin, Daniel and Giner, Lukas and Gruss, Daniel and Lipp, Moritz and Minkin, Marina and Moghimi, Daniel and Piessens, Frank and Schwarz, Michael and Sunar, Berk and Van Bulck, Jo and Yarom, Yuval},
  date = {2019-11-06},
  pages = {769--784},
  publisher = {{ACM}},
  location = {{London United Kingdom}},
  doi = {10.1145/3319535.3363219},
  url = {https://dl.acm.org/doi/10.1145/3319535.3363219},
  urldate = {2024-01-15},
  abstract = {Meltdown and Spectre enable arbitrary data leakage from memory via various side channels. Short-term software mitigations for Meltdown are only a temporary solution with a significant performance overhead. Due to hardware fixes, these mitigations are disabled on recent processors.},
  eventtitle = {{{CCS}} '19: 2019 {{ACM SIGSAC Conference}} on {{Computer}} and {{Communications Security}}},
  isbn = {978-1-4503-6747-9},
  langid = {english},
  file = {/home/thijs/Zotero/storage/QRNA4AVR/Canella et al. - 2019 - Fallout Leaking Data on Meltdown-resistant CPUs.pdf}
}

@article{canellaSystematicEvaluationTransient,
  title = {A {{Systematic Evaluation}} of {{Transient Execution Attacks}} and {{Defenses}}},
  author = {Canella, Claudio and Bulck, Jo Van and Schwarz, Michael and Lipp, Moritz},
  abstract = {Research on transient execution attacks including Spectre and Meltdown showed that exception or branch misprediction events might leave secret-dependent traces in the CPU’s microarchitectural state. This observation led to a proliferation of new Spectre and Meltdown attack variants and even more ad-hoc defenses (e.g., microcode and software patches). Both the industry and academia are now focusing on finding effective defenses for known issues. However, we only have limited insight on residual attack surface and the completeness of the proposed defenses.},
  langid = {english},
  file = {/home/thijs/Zotero/storage/53LNCGEW/Canella et al. - A Systematic Evaluation of Transient Execution Att.pdf}
}

@online{cooleyHyperVHyperClearMitigation2023,
  title = {Hyper-{{V HyperClear Mitigation}} for {{L1 Terminal Fault}}},
  author = {Cooley, Sarah and {Jahiu, Dhurata} and {Briggs, Matt} and {Chaurasia, Nikhil} and {Wong, Melanie} and {Schonning, Nick}},
  date = {2023-05-09},
  url = {https://learn.microsoft.com/en-us/virtualization/community/team-blog/2018/20180814-hyper-v-hyperclear-mitigation-for-l1-terminal-fault},
  urldate = {2024-02-15},
  abstract = {Learn about the mitigation effort for Hyper-V to address the new execution side channel vulnerability.},
  langid = {american},
  file = {/home/thijs/Zotero/storage/VRP74XQN/20180814-hyper-v-hyperclear-mitigation-for-l1-terminal-fault.html}
}

@online{CoreSchedulingLinux,
  title = {Core {{Scheduling}} — {{The Linux Kernel}} Documentation},
  url = {https://www.kernel.org/doc/html/latest/admin-guide/hw-vuln/core-scheduling.html},
  urldate = {2024-01-24},
  file = {/home/thijs/Zotero/storage/QCF9XLRG/core-scheduling.html}
}

@online{costanIntelSGXExplained2016,
  title = {Intel {{SGX Explained}}},
  author = {Costan, Victor and Devadas, Srinivas},
  date = {2016},
  number = {2016/086},
  url = {https://eprint.iacr.org/2016/086},
  urldate = {2024-01-23},
  abstract = {Intel's Software Guard Extensions (SGX) is a set of extensions to the Intel architecture that aims to provide integrity and privacy guarantees to security-sensitive computation performed on a computer where all the privileged software (kernel, hypervisor, etc) is potentially malicious. This paper analyzes Intel SGX, based on the 3 papers that introduced it, on the Intel Software Developer's Manual (which supersedes the SGX manuals), on an ISCA 2015 tutorial, and on two patents. We use the papers, reference manuals, and tutorial as primary data sources, and only draw on the patents to fill in missing information. This paper's contributions are a summary of the Intel-specific architectural and micro-architectural details needed to understand SGX, a detailed and structured presentation of the publicly available information on SGX, a series of intelligent guesses about some important but undocumented aspects of SGX, and an analysis of SGX's security properties.},
  pubstate = {preprint},
  annotation = {Publication info: Preprint.},
  file = {/home/thijs/Zotero/storage/6DCLX6UC/Costan and Devadas - 2016 - Intel SGX Explained.pdf}
}

@patent{doshiMethodsApparatusPerform2019,
  type = {patentus},
  title = {Methods and Apparatus to Perform Atomic Transactions in Nonvolatile Memory under Hardware Transactional Memory},
  author = {Doshi, Kshitij A. and Sukhomlinov, Vadim and Dementiev, Roman},
  holder = {{Intel Corp}},
  date = {2019-04-23},
  number = {10268502B2},
  url = {https://patents.google.com/patent/US10268502B2/en?q=(transactional+synchronization)&assignee=Intel+Corp,Intel+Corporation,Intel+IP+Corporation&oq=(transactional+synchronization)+assignee:(Intel+Corp)+assignee:(Intel+Corporation)+assignee:(Intel+IP+Corporation)},
  urldate = {2024-01-23},
  langid = {english},
  keywords = {commit,instruction,marker,transaction,transactions},
  file = {/home/thijs/Zotero/storage/MTF9LIDJ/Doshi et al. - 2019 - Methods and apparatus to perform atomic transactio.pdf}
}

@article{faggioliCoreSchedulingVirtualizationWhere,
  title = {Core-{{Scheduling}} for {{Virtualization}}: {{Where}} Are {{We}}? ({{If We Want It}}!)},
  author = {Faggioli, Dario},
  langid = {english},
  file = {/home/thijs/Zotero/storage/GF44P5IU/Core-Scheduling-Virtualization_KVMForum19_Faggioli.pdf}
}

@inproceedings{hertoghQuarantineMitigatingTransient2023,
  title = {Quarantine: {{Mitigating Transient Execution Attacks}} with {{Physical Domain Isolation}}},
  shorttitle = {Quarantine},
  booktitle = {Proceedings of the 26th {{International Symposium}} on {{Research}} in {{Attacks}}, {{Intrusions}} and {{Defenses}}},
  author = {Hertogh, Mathé and Wiesinger, Manuel and Österlund, Sebastian and Muench, Marius and Amit, Nadav and Bos, Herbert and Giuffrida, Cristiano},
  date = {2023-10-16},
  pages = {207--221},
  publisher = {{ACM}},
  location = {{Hong Kong China}},
  doi = {10.1145/3607199.3607248},
  url = {https://dl.acm.org/doi/10.1145/3607199.3607248},
  urldate = {2024-01-15},
  abstract = {Since the Spectre and Meltdown disclosure in 2018, the list of new transient execution vulnerabilities that abuse the shared nature of microarchitectural resources on CPU cores has been growing rapidly. In response, vendors keep deploying “spot” (per-variant) mitigations, which have become increasingly costly when combined against all the attacks—especially on older-generation processors. Indeed, some are so expensive that system administrators may not deploy them at all. Worse still, spot mitigations can only address known (N-day) attacks as they do not tackle the underlying problem: different security domains that run simultaneously on the same physical CPU cores and share their microarchitectural resources. In this paper, we propose Quarantine, a principled, softwareonly approach to mitigate transient execution attacks by eliminating sharing of microarchitectural resources. Quarantine decouples privileged and unprivileged execution and physically isolates different security domains on different CPU cores. We apply Quarantine to the Linux/KVM boundary and show it offers the system and its users blanket protection against malicous VMs and (unikernel) applications. Quarantine mitigates 24 out of the 27 known transient execution attacks on Intel CPUs and provides strong security guarantees against future attacks. On LMbench, Quarantine incurs a geomean overhead of 11.2\%, much lower than the default configuration of spot mitigations on Linux distros such as Ubuntu (even though the spot mitigations offer only partial protection).},
  eventtitle = {{{RAID}} 2023: {{The}} 26th {{International Symposium}} on {{Research}} in {{Attacks}}, {{Intrusions}} and {{Defenses}}},
  isbn = {9798400707650},
  langid = {english},
  file = {/home/thijs/Zotero/storage/4VNV2FI8/Hertogh et al. - 2023 - Quarantine Mitigating Transient Execution Attacks.pdf}
}

@article{hodHighlevelIntroductionVirtualization,
  title = {High-Level Introduction to Virtualization's Low-Level},
  author = {Hod, Ronen},
  langid = {english},
  file = {/home/thijs/Zotero/storage/9JW5JH6Z/Hod - High-level introduction to virtualization's low-le.pdf}
}

@article{Intel64IA322023,
  title = {{{Intel}}® 64 and {{IA-32 Architectures Software Developer}}’s {{Manual}}, {{Combined Volumes}}: 1, {{2A}}, {{2B}}, {{2C}}, {{2D}}, {{3A}}, {{3B}}, {{3C}}, {{3D}}, and 4},
  date = {2023},
  langid = {english},
  file = {/home/thijs/Zotero/storage/V42A3K9G/2023 - Intel® 64 and IA-32 Architectures Software Develop.pdf}
}

@article{koruyehSpectreReturnsSpeculation2024,
  title = {Spectre {{Returns}}! {{Speculation Attacks}} Using the {{Return Stack Buffer}}},
  author = {Koruyeh, Esmaeil Mohammadian and Khasawneh, Khaled N. and Song, Chengyu and Abu-Ghazaleh, Nael},
  date = {2024},
  journaltitle = {IEEE Design \& Test},
  shortjournal = {IEEE Des. Test},
  pages = {1--1},
  issn = {2168-2356, 2168-2364},
  doi = {10.1109/MDAT.2024.3352537},
  url = {https://ieeexplore.ieee.org/document/10387456/},
  urldate = {2024-01-22},
  abstract = {The recent Spectre attacks exploit speculative execution, a pervasively used feature of modern microprocessors, to allow the exfiltration of sensitive data across protection boundaries. In this paper, we introduce a new Spectreclass attack that we call SpectreRSB. In particular, rather than exploiting the branch predictor unit, SpectreRSB exploits the return stack buffer (RSB), a common predictor structure in modern CPUs used to predict return addresses. We show that both local attacks (within the same process such as Spectre 1) and attacks on SGX are possible by constructing proof of concept attacks. We also analyze additional types of the attack on the kernel or across address spaces and show that under some practical and widely used conditions they are possible. Importantly, none of the known defenses including Retpoline and Intel’s microcode patches stop all SpectreRSB attacks. We believe that future system developers should be aware of this vulnerability and consider it in developing defenses against speculation attacks. In particular, on Core-i7 Skylake and newer processors (but not on Intel’s Xeon processor line), a patch called RSB refilling is used to address a vulnerability when the RSB underfills; this defense interferes with SpectreRSB’s ability to launch attacks that switch into the kernel. We recommend that this patch should be used on all machines to protect against SpectreRSB.},
  langid = {english},
  file = {/home/thijs/Zotero/storage/GLDY38HJ/Koruyeh et al. - 2024 - Spectre Returns! Speculation Attacks using the Ret.pdf}
}

@inproceedings{maisuradzeRet2specSpeculativeExecution2018,
  title = {Ret2spec: {{Speculative Execution Using Return Stack Buffers}}},
  shorttitle = {Ret2spec},
  booktitle = {Proceedings of the 2018 {{ACM SIGSAC Conference}} on {{Computer}} and {{Communications Security}}},
  author = {Maisuradze, Giorgi and Rossow, Christian},
  date = {2018-10-15},
  pages = {2109--2122},
  publisher = {{ACM}},
  location = {{Toronto Canada}},
  doi = {10.1145/3243734.3243761},
  url = {https://dl.acm.org/doi/10.1145/3243734.3243761},
  urldate = {2024-01-22},
  abstract = {Speculative execution is an optimization technique that has been part of CPUs for over a decade. It predicts the outcome and target of branch instructions to avoid stalling the execution pipeline. However, until recently, the security implications of speculative code execution have not been studied. In this paper, we investigate a special type of branch predictor that is responsible for predicting return addresses. To the best of our knowledge, we are the first to study return address predictors and their consequences for the security of modern software. In our work, we show how return stack buffers (RSBs), the core unit of return address predictors, can be used to trigger misspeculations. Based on this knowledge, we propose two new attack variants using RSBs that give attackers similar capabilities as the documented Spectre attacks. We show how local attackers can gain arbitrary speculative code execution across processes, e.g., to leak passwords another user enters on a shared system. Our evaluation showed that the recent Spectre countermeasures deployed in operating systems can also cover such RSB-based crossprocess attacks. Yet we then demonstrate that attackers can trigger misspeculation in JIT environments in order to leak arbitrary memory content of browser processes. Reading outside the sandboxed memory region with JIT-compiled code is still possible with 80\% accuracy on average.},
  eventtitle = {{{CCS}} '18: 2018 {{ACM SIGSAC Conference}} on {{Computer}} and {{Communications Security}}},
  isbn = {978-1-4503-5693-0},
  langid = {english},
  file = {/home/thijs/Zotero/storage/FIBA5J2J/Maisuradze and Rossow - 2018 - ret2spec Speculative Execution Using Return Stack.pdf}
}

@online{MDSAttacksMicroarchitectural,
  title = {{{MDS Attacks}}: {{Microarchitectural Data Sampling}}},
  url = {https://mdsattacks.com/},
  urldate = {2019-11-14},
  file = {/home/thijs/Zotero/storage/HPQI8VBK/mdsattacks.com.html}
}

@article{moghimiDownfallExploitingSpeculative,
  title = {Downfall: {{Exploiting Speculative Data Gathering}}},
  author = {Moghimi, Daniel},
  abstract = {We introduce Downfall attacks, new transient execution attacks that undermine the security of computers running everywhere across the internet. We exploit the gather instruction on high-performance x86 CPUs to leak data across boundaries of user-kernel, processes, virtual machines, and trusted execution environments. We also develop practical and end-to-end attacks to steal cryptographic keys, program’s runtime data, and even data at rest (arbitrary data). Our findings, exploitation techniques, and demonstrated attacks defeat all previous defenses, calling for critical hardware fixes and security updates for widely-used client and server computers.},
  langid = {english},
  file = {/home/thijs/Zotero/storage/4DSE628G/Moghimi - Downfall Exploiting Speculative Data Gathering.pdf}
}

@inproceedings{moghimiMedusaMicroarchitecturalData2020,
  title = {Medusa: {{Microarchitectural Data Leakage}} via {{Automated Attack Synthesis}}},
  shorttitle = {Medusa},
  author = {Moghimi, Daniel and Lipp, Moritz and Sunar, Berk and Schwarz, Michael},
  date = {2020},
  pages = {1427--1444},
  url = {https://www.usenix.org/conference/usenixsecurity20/presentation/moghimi-medusa},
  urldate = {2024-01-25},
  eventtitle = {29th {{USENIX Security Symposium}} ({{USENIX Security}} 20)},
  isbn = {978-1-939133-17-5},
  langid = {english},
  file = {/home/thijs/Zotero/storage/4ZY6U7VQ/Moghimi et al. - 2020 - Medusa Microarchitectural Data Leakage via Automa.pdf}
}

@online{mosierSerberusProtectingCryptographic2023,
  title = {Serberus: {{Protecting Cryptographic Code}} from {{Spectres}} at {{Compile-Time}}},
  shorttitle = {Serberus},
  author = {Mosier, Nicholas and Nemati, Hamed and Mitchell, John C. and Trippel, Caroline},
  date = {2023-09-10},
  eprint = {2309.05174},
  eprinttype = {arxiv},
  eprintclass = {cs},
  url = {http://arxiv.org/abs/2309.05174},
  urldate = {2024-01-22},
  abstract = {We present SERBERUS, the first comprehensive mitigation for hardening constant-time (CT) code against Spectre attacks (involving the PHT, BTB, RSB, STL, and/or PSF speculation primitives) on existing hardware. SERBERUS is based on three insights. First, some hardware control-flow integrity (CFI) protections restrict transient control-flow to the extent that it may be comprehensively considered by software analyses. Second, conformance to the accepted CT code discipline permits two code patterns that are unsafe in the post-Spectre era. Third, once these code patterns are addressed, all Spectre leakage of secrets in CT programs can be attributed to one of four classes of taint primitives—instructions that can transiently assign a secret value to a publicly-typed register. We evaluate SERBERUS on cryptographic primitives in the OPENSSL, LIBSODIUM, and HACL* libraries. SERBERUS introduces 21.3\% runtime overhead on average, compared to 24.9\% for the next closest state-of-the-art software mitigation, which is less secure.},
  langid = {english},
  pubstate = {preprint},
  keywords = {Computer Science - Cryptography and Security,Computer Science - Hardware Architecture},
  file = {/home/thijs/Zotero/storage/WVAVL8PG/Mosier et al. - 2023 - Serberus Protecting Cryptographic Code from Spect.pdf}
}

@misc{salzmanLinuxKernelModule2024,
  title = {The {{Linux Kernel Module Programming Guide}}},
  author = {Salzman, Peter Jay and Burian, Michael and Pomerantz, Ori and Mottram, Bob and Huang, Jim},
  date = {2024-01-03},
  url = {https://github.com/sysprog21/lkmpg/releases/download/latest/lkmpg.pdf},
  langid = {english},
  file = {/home/thijs/Zotero/storage/KQAC65KZ/The Linux Kernel Module Programming Guide.pdf}
}

@inproceedings{schwarzZombieLoadCrossPrivilegeBoundaryData2019,
  title = {{{ZombieLoad}}: {{Cross-Privilege-Boundary Data Sampling}}},
  shorttitle = {{{ZombieLoad}}},
  booktitle = {Proceedings of the 2019 {{ACM SIGSAC Conference}} on {{Computer}} and {{Communications Security}}},
  author = {Schwarz, Michael and Lipp, Moritz and Moghimi, Daniel and Van Bulck, Jo and Stecklina, Julian and Prescher, Thomas and Gruss, Daniel},
  date = {2019-11-06},
  pages = {753--768},
  publisher = {{ACM}},
  location = {{London United Kingdom}},
  doi = {10.1145/3319535.3354252},
  url = {https://dl.acm.org/doi/10.1145/3319535.3354252},
  urldate = {2024-01-23},
  abstract = {In early 2018, Meltdown first showed how to read arbitrary kernel memory from user space by exploiting side-effects from transient instructions. While this attack has been mitigated through stronger isolation boundaries between user and kernel space, Meltdown inspired an entirely new class of fault-driven transient-execution attacks. Particularly, over the past year, Meltdown-type attacks have been extended to not only leak data from the L1 cache but also from various other microarchitectural structures, including the FPU register file and store buffer.},
  eventtitle = {{{CCS}} '19: 2019 {{ACM SIGSAC Conference}} on {{Computer}} and {{Communications Security}}},
  isbn = {978-1-4503-6747-9},
  langid = {english},
  file = {/home/thijs/Zotero/storage/3RB6T6F3/Schwarz et al. - 2019 - ZombieLoad Cross-Privilege-Boundary Data Sampling.pdf}
}

@book{tanenbaumStructuredComputerOrganization2013,
  title = {Structured Computer Organization},
  author = {Tanenbaum, Andrew S. and Austin, Todd},
  date = {2013},
  series = {Always Learning},
  edition = {6. ed},
  publisher = {{Pearson}},
  location = {{Boston, Mass. Munich}},
  isbn = {978-0-13-291652-3},
  langid = {english},
  pagetotal = {775},
  file = {/home/thijs/Zotero/storage/DJ5G86K8/Tanenbaum and Austin - 2013 - Structured computer organization.pdf}
}

@online{turnerProtectingNewL1TF2018,
  title = {Protecting against the New “{{L1TF}}” Speculative Vulnerabilities},
  author = {Turner, Paul and Parseghian, Pat},
  date = {2018-08-15},
  url = {https://cloud.google.com/blog/products/gcp/protecting-against-the-new-l1tf-speculative-vulnerabilities},
  urldate = {2024-02-15},
  langid = {american},
  organization = {{Google Cloud Blog}},
  file = {/home/thijs/Zotero/storage/4BGEV49L/protecting-against-the-new-l1tf-speculative-vulnerabilities.html}
}

@inproceedings{vanschaikRIDLRogueInFlight2019,
  title = {{{RIDL}}: {{Rogue In-Flight Data Load}}},
  shorttitle = {{{RIDL}}},
  booktitle = {2019 {{IEEE Symposium}} on {{Security}} and {{Privacy}} ({{SP}})},
  author = {Van Schaik, Stephan and Milburn, Alyssa and Osterlund, Sebastian and Frigo, Pietro and Maisuradze, Giorgi and Razavi, Kaveh and Bos, Herbert and Giuffrida, Cristiano},
  date = {2019-05},
  pages = {88--105},
  publisher = {{IEEE}},
  location = {{San Francisco, CA, USA}},
  doi = {10.1109/SP.2019.00087},
  url = {https://ieeexplore.ieee.org/document/8835281/},
  urldate = {2024-01-15},
  abstract = {We present Rogue In-flight Data Load (RIDL)1, a new class of unprivileged speculative execution attacks to leak arbitrary data across address spaces and privilege boundaries (e.g., process, kernel, SGX, and even CPU-internal operations). Our reverse engineering efforts show such vulnerabilities originate from a variety of micro-optimizations pervasive in commodity (Intel) processors, which cause the CPU to speculatively serve loads using extraneous CPU-internal in-flight data (e.g., in the line fill buffers). Contrary to other state-of-the-art speculative execution attacks, such as Spectre, Meltdown and Foreshadow, RIDL can leak this arbitrary in-flight data with no assumptions on the state of the caches or translation data structures controlled by privileged software.},
  eventtitle = {2019 {{IEEE Symposium}} on {{Security}} and {{Privacy}} ({{SP}})},
  isbn = {978-1-5386-6660-9},
  langid = {english},
  file = {/home/thijs/Zotero/storage/EJCKD9IS/Van Schaik et al. - 2019 - RIDL Rogue In-Flight Data Load.pdf}
}

@article{weisseForeshadowNGBreakingVirtual,
  title = {Foreshadow-{{NG}}: {{Breaking}} the {{Virtual Memory Abstraction}} with {{Transient Out-of-Order Execution}}},
  author = {Weisse, Ofir and Bulck, Jo Van and Minkin, Marina and Genkin, Daniel and Kasikci, Baris and Piessens, Frank and Silberstein, Mark and Strackx, Raoul and Wenisch, Thomas F and Yarom, Yuval},
  abstract = {In January 2018, we discovered the Foreshadow transient execution attack (USENIX Security’18) targeting Intel SGX technology. Intel’s subsequent investigation of our attack uncovered two closely related variants, which we collectively call Foreshadow-NG and which Intel refers to as L1 Terminal Fault. Current analyses focus mostly on mitigation strategies, providing only limited insight into the attacks themselves and their consequences. The aim of this report is to alleviate this situation by thoroughly analyzing Foreshadow-type attacks and their implications in the light of the emerging transient execution research area.},
  langid = {english},
  file = {/home/thijs/Zotero/storage/MXZ2347B/Weisse et al. - Foreshadow-NG Breaking the Virtual Memory Abstrac.pdf}
}

@online{weissmanMicroarchitecturalSecurityAWS2023a,
  title = {Microarchitectural {{Security}} of {{AWS Firecracker VMM}} for {{Serverless Cloud Platforms}}},
  author = {Weissman, Zane and Tiemann, Thore and Eisenbarth, Thomas and Sunar, Berk},
  date = {2023-11-27},
  eprint = {2311.15999},
  eprinttype = {arxiv},
  eprintclass = {cs},
  url = {http://arxiv.org/abs/2311.15999},
  urldate = {2024-01-23},
  abstract = {Firecracker is a virtual machine manager (VMM) purpose-built by Amazon Web Services (AWS) for serverless cloud platforms—services that run code for end users on a per-task basis, automatically managing server infrastructure. Firecracker provides fast and lightweight VMs and promises a combination of the speed of containers, typically used to isolate small tasks, and the security of VMs, which tend to provide greater isolation at the cost of performance. This combination of security and efficiency, AWS claims, makes it not only possible but safe to run thousands of user tasks from different users on the same hardware, with the host system rapidly and frequently switching between active tasks. Though AWS states that microarchitectural attacks are included in their threat model, this class of attacks directly relies on shared hardware, just as the scalability of serverless computing relies on sharing hardware between unprecedented numbers of users. In this work, we investigate just how secure Firecracker is against microarchitectural attacks. First, we review Firecracker’s stated isolation model and recommended best practices for deployment, identify potential threat models for serverless platforms, and analyze potential weak points. Then, we use microarchitectural attack proof-of-concepts to test the isolation provided by Firecracker and find that it offers little protection against Spectre or MDS attacks. We discover two particularly concerning cases: 1) a Medusa variant that threatens Firecracker VMs but not processes running outside them, and is not mitigated by defenses recommended by AWS, and 2) a Spectre-PHT variant that remains exploitable even if recommended countermeasures are in place and SMT is disabled in the system. In summary, we show that AWS overstates the security inherent to the Firecracker VMM and provides incomplete guidance for properly securing cloud systems that use Firecracker.},
  langid = {english},
  pubstate = {preprint},
  keywords = {Computer Science - Cryptography and Security},
  file = {/home/thijs/Zotero/storage/Y2HGK6HR/Weissman et al. - 2023 - Microarchitectural Security of AWS Firecracker VMM.pdf}
}

@article{yaromFLUSHRELOADHigh,
  title = {{{FLUSH}}+{{RELOAD}}: A {{High Resolution}}, {{Low Noise}}, {{L3 Cache Side-Channel Attack}}},
  author = {Yarom, Yuval and Falkner, Katrina},
  abstract = {Sharing memory pages between non-trusting processes is a common method of reducing the memory footprint of multi-tenanted systems. In this paper we demonstrate that, due to a weakness in the Intel X86 processors, page sharing exposes processes to information leaks. We present FLUSH+RELOAD, a cache side-channel attack technique that exploits this weakness to monitor access to memory lines in shared pages. Unlike previous cache side-channel attacks, FLUSH+RELOAD targets the LastLevel Cache (i.e. L3 on processors with three cache levels). Consequently, the attack program and the victim do not need to share the execution core.},
  langid = {english},
  file = {/home/thijs/Zotero/storage/CJSDUPIX/Yarom and Falkner - FLUSH+RELOAD a High Resolution, Low Noise, L3 Cac.pdf}
}
